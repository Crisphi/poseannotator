<!DOCTYPE html>
<html>
  <head>
    <title>Pose Annotator</title>
    <meta charset="UTF-8">
    <meta name="author" content="Cristian Ortega Singer">
    <script src="https://code.jquery.com/jquery-latest.js"></script>
    <!-- import jszip.js for zipping-->
    <!-- <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.1.4/jszip.min.js"></script> -->
    <!-- FileSaver.js for better downloading-->
    <!-- <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/1.3.3/FileSaver.min.js"></script> -->
    <style>
      div {border-style: dotted;}
      body {display: grid;}
      #header{
        grid-column: 1/span 3;
        grid-row: 1/ span 2;
      }
      #sidebar{
        grid-column: 1;
        grid-row: 2/span 7;
      }
      #workspace{
        grid-column: 2/span 3;
        grid-row: 2/span 5;
        grid-template-columns: max-content;
      }

      #footer{
        grid-column: 1/span 3;
        grid-row: 7;
      }

      .gridItem{display:grid;}

      #img-svg-wrap{
        position: relative;
        display: inline-block;
      }

      #image{
        display: absolute;
        max-width: 100%;
        min-width: 100%;
        height: auto;
      }

      #svg{
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
      }

      line{
        fill:none;
        stroke-width:3;
        stroke: black;
      }
      .black{
        stroke:black;
      }
      .orange{
        stroke:orange;
      }

      .point{
        stroke: black;
      }

      #createDescr{
        display:none;
      }
    </style>
  </head>
  <body>
    <div id="header" class="gridItem">
      Pose Annotator
      <form name="upload-metadata">
        <input type="file" id="metadata" accept="application/json" multiple>
        </br>
        <input type="file" id="images" accept="image/*" multiple>
        <button type="button" id="importButton" onclick="handleFiles();">Import Files</button>
        <input type="file" id="workingfile" accept="application/json">
        <button type="button" id="loadButton" onclick="handleWorkingFile();">Load Project </button>
        <button type="button" id="exportButton" onclick="exportUnfinished();">Export Files</button>
      </form>
    </div>
    <div id="main" class="gridItem">
      <div id="sidebar" class="gridItem">
        Here are going to be all the tools and an overview of the images
          <p> Checked: <span id = "checked">No</span></p>
          <div id="files">
            <p>Images:<P>
            <ul id="fileview"></ul>
          </div>
        <div id="tools">Tools
          <button type="button" id="undoButton" onclick="resetPage();">Undo all Changes on this Image</button>
          <button type="button" id="resetButton" onclick="toggleResetMode(!resetMode);">Reset Mode</button>
          <button type="button" id="createButton" onclick="toggleCreationMode(!creationMode);">Creation Mode</button>
          <button type="button" id="deleteButton" onclick="toggleDeletionMode(!deletionMode);">Deletion Mode</button>
          <div id="optionsContainer">
            <p id="createDescr">Possible Points to add (klick on joint where a part of the pose is missing):</p>
          </div>
        </div>
        <div id="files">Files</div>
        <div id="arrows">
          <button type="button" id="lastPic" onclick="previousImage();">Prev</button>
          <button type="button" id="nextPic" onclick="nextImage();">Next</button>
        </div>
      </div>
      <div id="workspace" class="gridItem">
        <div id="img-svg-wrap">
          <img x= 0 y= 0 id="image" href="" alt="current Picture">
          <svg id="svg" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" onload="draggable(evt)">

          </svg>
        </div>
      </div>
    </div>
    <div id="footer" class="gridItem">
      Footer
    </div>

    <script type="text/javascript">
    "use strict";

    //initializing variables
      var IMG_FILEPATH = "img/";
      var META_FILEPATH = "metadata/";
      var single_meta_file = false;
      var working_file = false;
      var meta_file_list = {};
      var annotations;
      var image_file_list = {};
      var current_image_id;
      var current_image_source;
      var meta_id;
      var unsavedChanges = {};

      var fileview;

      var working_file_list = {};
      var working_data = {};

      var color = "black";
      var resetMode = false;
      var creationMode = false;
      var deletionMode = false;

      var bodyparts = {};

      var bodyschema = {
        "head1" : [0, 15],
        "head2" : [0, 16],
        "head3" : [15, 17],
        "head4" : [16, 18],
        "spine1": [0, 1],
        "spine2": [1, 8],
        "armL1" : [1, 2],
        "armL2" : [2, 3],
        "armL3" : [3, 4],
        "armR1" : [1, 5],
        "armR2" : [5, 6],
        "armR3" : [6, 7],
        "legL1" : [8, 9],
        "legL2" : [9, 10],
        "legL3" : [10, 11],
        "legR1" : [8, 12],
        "legR2" : [12, 13],
        "legR3" : [13, 14],
        "footL1": [11, 22],
        "footL2": [22, 23],
        "footL3": [11, 24],
        "footR1": [14, 19],
        "footR2": [19, 20],
        "footR3": [14, 21]
      };

      var highlighted;
      var creating;
      var creationPoint;
      var selectedElement;
      var offset;
      var transform;
      var bbox;
      var minX;
      var minY;
      var maxX;
      var maxY;
      var boundaryX1 = 0;
      var boundaryY1 = 0;
      var boundaryX2 = document.getElementById("svg").width;
      var boundaryY2 = document.getElementById("svg").height;
      var svgNS = "http://www.w3.org/2000/svg";

      // Check for the various File API support.
      if (!window.File || !window.FileReader || !window.FileList || !window.Blob) {
        alert("The File APIs are not fully supported in this browser.");
      }

      //various event listeners for tracking key and mouse navigation
      document.addEventListener("keydown", function(event) {
        if(event.keyCode == 37) {
          console.log("Left was pressed");
          previousImage();
        }
        else if(event.keyCode == 39) {
          console.log("Right was pressed");
          nextImage();
        }
        else if(event.keyCode == 40) {
          console.log("Down was pressed");
          changeAnnoColor();
        }
        else if(event.keyCode == 68){
          console.log("d was pressed");
          toggleDeletionMode(!deletionMode);
        }else if(event.keyCode == 67){
          console.log("c was pressed");
          toggleCreationMode(!creationMode);
        }else if(event.keyCode == 82){
          console.log("r was pressed");
          toggleResetMode(!resetMode);
        }
      });

      //function for making the annotation points draggable
      function draggable(evt){
        var svg = evt.target;

        //set event listeners for mouse movement
        svg.addEventListener("mousedown", function(event){
          if(creating){
            creating = false;
            endDrag(event);
          }else if(resetMode){
            undoChanges(event);
          }else if(creationMode){
            addAnnotation(event);
          }else if(deletionMode){
            deletePoint(event);
          }else{
            startDrag(event);
          }
        });
        svg.addEventListener("mousedown", startDrag);
        svg.addEventListener("mousemove", drag);
        svg.addEventListener("mouseup", endDrag);
        svg.addEventListener("mouseleave", endDrag);

        //currently not working! function for adding new points to an uncomplete bodyschema
        function addAnnotation(evt){
          var descr = document.getElementById("createDescr");
          var svg = document.getElementById("svg");
          var children = svg.childNodes;
          if(evt.target.classList.contains("point")){
            if(highlighted){
              highlighted.removeAttribute("style");
              deleteDescr();
            }
            selectedElement = evt.target;
            highlighted = selectedElement;
            selectedElement.setAttributeNS(null, "style", "fill: red;")
            var pointId = selectedElement.getAttribute("id");
            var ids = pointId.split(" ");
            var pointschemaId = ids[1];
            var poseId = ids[0];

            for(var i in bodyschema){
              if(bodyschema[i][0] == pointschemaId){
                //console.log(bodyschema[i]);
                for(var j = 0; j < children.length; j++){
                  if(children[j].classList.contains("point")){
                    var pointId2 = children[j].getAttribute("id");
                    var ids2 = pointId2.split(" ");
                    if((ids2[1] == bodyschema[i][1]) && (ids2[0] == ids[0])){
                      console.log(children[j].getAttribute("cx"));
                      var xTemp = parseInt(children[j].getAttribute("cx"));
                      var yTemp = parseInt(children[j].getAttribute("cy"));
                      if((xTemp == "0") && (yTemp == "0")){
                        console.log(xTemp, yTemp);
                        console.log(i);
                        var btn = document.createElement("BUTTON");
                        btn.innerHTML = i;
                        btn.setAttribute("pointId", pointId);
                        btn.setAttribute("onclick", "fireButton(this);")
                        descr.appendChild(btn);
                        console.log(pointId);
                      }
                    }
                  }
                }
              }
            }
          }
        }

        //set coordinates of selected point back to default
        function undoChanges(evt){
          if(evt.target.classList.contains("point")){
            selectedElement = evt.target;
            if(selectedElement.hasAttributeNS(null,"transform")){
              selectedElement.removeAttributeNS(null, "transform");

              var lineIds = getLineIds();

              var x = selectedElement.getAttributeNS(null, "cx");
              var y = selectedElement.getAttributeNS(null, "cy");
              for(var k in lineIds){
                //console.log(k);
                var line = document.getElementById(k.toString());

                if(line){
                  if(lineIds[k] == 0){
                    line.setAttributeNS(null,"x1", x);
                    line.setAttributeNS(null,"y1", y);
                    //console.log("changed x1 and y1");
                  }else if(lineIds[k] == 1){
                    line.setAttributeNS(null,"x2", x);
                    line.setAttributeNS(null,"y2", y);
                    //console.log("changed x2 and y2");
                  }else{
                    console.log("An error occured. Look in source code function undoChanges() to see what happened.");
                  }
                }
              }
            }
          }
        }

        //Delete parts of the pose
        function deletePoint(evt){
          console.log("Point Deletion");

          if(evt.target.classList.contains("point")){
            selectedElement = evt.target;
            //removes transformations if they exist
            if(selectedElement.hasAttributeNS(null,"transform")){
              selectedElement.removeAttributeNS(null, "transform");
              //sets coordinates of point to 0
              selectedElement.setAttributeNS(null, "cx", 0);
              selectedElement.setAttributeNS(null, "cy", 0);

              //get all lines that connect to point
              var lineIds = getLineIds();
              //delete all connected lines
              for(var k in lineIds){
                //console.log(k);
                var line = document.getElementById(k.toString());
                if(line){
                  line.remove();
                }
              }
            }
          }
        }
        //track mouseposition on screen if mouse interacts with svg
        function getMousePos(evt){
          var ctm = svg.getScreenCTM();
          if(evt.touches){
            evt = evt.touches[0];
          }
          return{
            x: (evt.clientX - ctm.e) / ctm.a,
            y: (evt.clientY - ctm.f) / ctm.d
          };
        }

        // handles mousedown event, starts dragging process
        function startDrag(evt){
          var svgtemp = document.getElementById("svg");

          //set boundaries to Imagesize so that it is impossible to drag points out of view
          boundaryX2 = svgtemp.width.baseVal.value;
          boundaryY2 = svgtemp.height.baseVal.value;

          //console.log("Boundaries:");
          //console.log(boundaryX2);
          //console.log(boundaryY2);

          //correct mouse offset in relation to svg through a transformation
          if(evt.target.classList.contains("point")){
            selectedElement = evt.target;
            offset = getMousePos(evt);
            //console.log(offset);

            var transforms = selectedElement.transform.baseVal;

            if(transforms.length === 0 || transforms.getItem(0).type !== SVGTransform.SVG_TRANSFORM_TRANSLATE){
              var translate = svg.createSVGTransform();
              translate.setTranslate(0,0);
              selectedElement.transform.baseVal.insertItemBefore(translate,0);
            }

            transform = transforms.getItem(0);
            offset.x -= transform.matrix.e;
            offset.y -= transform.matrix.f;

            //console.log(offset.x);
            //console.log(offset.y);

            //set boundaries according to the collision box of svg element
            bbox = selectedElement.getBBox();
            minX = boundaryX1 - bbox.x;
            maxX = boundaryX2 -bbox.x - bbox.width;
            minY = boundaryY1 - bbox.y;
            maxY = boundaryY2 - bbox.y - bbox.height;
          }
        }

        //handles mousemove event; the dragging process itself
        function drag(evt){
          if(selectedElement){
            evt.preventDefault();
            var coord = getMousePos(evt);
            var dx = coord.x - offset.x;
            var dy = coord.y - offset.y;

            //make shure svg element stays within boundaries
            if(dx < minX){
              dx = minX;
            }else if(dx >maxX){
              dx = maxX;
            }

            if(dy < minY){
              dy = minY;
            }else if(dy > maxY){
              dy = maxY;
            }
            //set new position for svg point
            transform.setTranslate(dx, dy);
            var lineIds = getLineIds();

            for(var k in lineIds){
              //console.log(k);
              var line = document.getElementById(k.toString());

              if(line){
                if(lineIds[k] == 0){
                  line.setAttributeNS(null,"x1", coord.x);
                  line.setAttributeNS(null,"y1", coord.y);
                  //console.log("changed x1 and y1");
                }else if(lineIds[k] == 1){
                  line.setAttributeNS(null,"x2", coord.x);
                  line.setAttributeNS(null,"y2", coord.y);
                  //console.log("changed x2 and y2");
                }else{
                  console.log("An error occured. Look in source code function pointchange() to see what happened.");
                }
              }
            }
          }
        }

        //set new position for svg lines if selected point is one of the coordinates
        function getLineIds (){
          //get point id and bodyschema ids for identifing correct lines
          var pointId = selectedElement.getAttribute("id");
          var ids = pointId.split(" ");
          var pointschemaId = ids[1];
          var poseId = ids[0];
          //console.log("Pointschema Id: " + pointschemaId);
          var lineIds = {};
          //get all bodyparts that have the right identifier
          for(var i in bodyschema){
            for(var j = 0; j < bodyschema[i].length; j++){
              if(bodyschema[i][j] == pointschemaId){
                lineIds[poseId + " " + i] = j;
              }
            }
          }
          return lineIds;
        }

        //handles mouseup and mouseleave events; stops dragging process
        function endDrag (evt){
          selectedElement = false;
        }
      }
      //currently not working a failed try to create points of specific bodyparts
      function fireButton(btn){
        console.log("fired Button event");
        var pointId = btn.getAttribute("pointId");
        var point = document.getElementById(pointId);

        var eventDown = new MouseEvent("mousedown");
        point.dispatchEvent(eventDown);
        var eventMove = new MouseEvent("mousemove");
      }

        //Not finished will be included in future versions: load json file if the annotations are saved in only one json file
      function loadMetaFileSingle(){

      }

      //load current json file if the annotations are saved in multiple json files
      function loadMetaFiles(){
        single_meta_file = false;

        //console.log(meta_file_list);

        //get name of json file through the name of the image file
        var id = current_image_source.split(".")[0];
        //create a new regex pattern
        var patt = new RegExp(id + "_");

        //console.log(id);
        //search in loaded meta files for the correct file via file name and save file in meta_id
        for(var i = 0; i < meta_file_list.length; i++){
          var d = meta_file_list[i];
          if(patt.test(d.name)){
            //console.log(d);
            meta_id = d;
          }
        }

        //if file found launch a file reader to get content of file as a string array
        if(meta_id){
          var reader = new FileReader();
          reader.onload = getAnnotations;
          //console.log(meta_id);
          reader.readAsText(meta_id);
        }

        function getAnnotations(t, callback = function(){loadAnnotations();}){
          //console.log(callback);
          let lines = t.target.result;
          var a = JSON.parse(lines);
          annotations = $.extend(annotations,a);
          //console.log("Annotations:");
          //console.log(annotations);
          callback();
        }
      }

      //initiate the file reading process of json and image files
      function handleFiles(){
        workingfile = false;
        //get json and image files from the file selector
        image_file_list = document.getElementById("images").files;
        meta_file_list = document.getElementById("metadata").files;

        displayFileList();
        //catching errors
        if(!image_file_list[0]){
          alert("You have to select image files before you can continue!");
        }else if(!meta_file_list[0]){
          alert("You have to select JSON files before you can continue!");
        }else if(image_file_list[0] && meta_file_list[0]){
          console.log(image_file_list);
          console.log(meta_file_list);
          if(annotations){
            if(confirm("Annotations already included! Unsaved changes will be lost! Do you want to replace annotation File(s)?")){
              current_image_id = 0;
              loadImage();
              annotations = {};
              unsavedChanges = {};
              if(meta_file_list.length > 1){
                loadMetaFiles();
              }else{
                loadMetaFileSingle();
              }
            }
          }else{
            current_image_id = 0;
            loadImage();
            annotations = {};
            unsavedChanges = {};
            //check if there are multiple json files or just one
            if(meta_file_list.length > 1){
              loadMetaFiles();
            }else{
              loadMetaFileSingle();
            }
          }
        }
      }

      //display image
      function loadImage(){
        destroySvgEl();
        if(!image_file_list[current_image_id]){
          //console.log(current_image_id);
          alert("An Error occured! No Image Id found.")
        }else{
          var imag = document.getElementById("image");
          current_image_source = image_file_list[current_image_id].name;

          if(imag.complete){
            var new_image = new Image();
            new_image.id = "image";
            new_image.src = IMG_FILEPATH + current_image_source;
            imag.parentNode.insertBefore(new_image, imag);
            imag.parentNode.removeChild(imag);
          }
        }
      }

      function handleWorkingFile(){
        workingfile = true;
        single_meta_file = false;
        working_file_list = document.getElementById("workingfile").files;
        if(!working_file_list[0]){
          alert("You have to select a project to load before you can continue!");
        }else{
          console.log(working_file_list);
          if(annotations){
            if(confirm("Annotations already included! Unsaved changes will be lost! Do you want to replace annotation File(s)?")){
              readWorkingFile();
            }
          }else{
            readWorkingFile();
          }
        }

        function readWorkingFile(){
          current_image_id = 0;
          annotations = {};
          unsavedChanges = {};

          var reader = new FileReader();
          reader.onload = getAnnotations;
          console.log(working_file_list[0]);
          reader.readAsText(working_file_list[0]);
          console.log(reader.readyState);

          function getAnnotations(t, callback = function(){
              console.log("Working Data:");
              console.log(working_data);
              var imageListTemp = [];
              var metaListTemp = [];
              for(var i in working_data){
                imageListTemp[i] = {"name" : working_data[i].image_source};
                metaListTemp[i] = {"name" : working_data[i].meta_source};
              }
              image_file_list = imageListTemp.slice();
              meta_file_list = metaListTemp.slice();
              /**image_file_list = Object.assign({}, imageListTemp);
              meta_file_list = Object.assign({}, metaListTemp);**/
              console.log(image_file_list);
              console.log(meta_file_list);

              displayFileList();
              loadImage();
              loadWorkingMeta();
            }){
            //console.log(callback);
            let lines = t.target.result;
            var a = JSON.parse(lines);
            working_data = $.extend(working_data,a);
            callback();
          }
        }
      }

      function loadWorkingMeta(){
        var checkObject = document.getElementById("checked");

        for(var i in working_data){
          if(current_image_source == working_data[i].image_source){
            annotations["people"] = Object.values(working_data[i].people);
            if(working_data[i].checked == true){
              checkObject.innerHTML = "Yes";
            }else{
              checkObject.innerHTML = "No";
            }
            console.log("Annotations:");
            console.log(annotations);
            loadAnnotations();
          }
        }
      }

      //disables all modes (optional leave current mode on)
      function disableModes(current = ""){
        if(current == "resetMode"){
          creationMode = false;
          deletionMode = false;
        }else if(current == "deletionMode"){
          creationMode = false;
          resetMode = false;
        }else if(current == "creationMode"){
          resetMode = false;
          deletionMode = false;
        }else{
          creationMode = false;
          resetMode = false;
          deletionMode = false;
        }
      }

      //function for loading next image with annotations
      function nextImage(){
        disableModes();
        deleteDescr();
        cacheAnnotations();
        if(current_image_id >= image_file_list.length -1){
          current_image_id = 0;
        }else{
          current_image_id++;
        }
        loadImage();
        if(workingfile){
          loadWorkingMeta();
        }else if(single_meta_file){
          loadMetaFileSingle();
        }else{
          loadMetaFiles();
        }
      }

      //function for loading previous image with annotations
      function previousImage(){
        disableModes();
        deleteDescr();
        cacheAnnotations();
        if(current_image_id <= 0){
          current_image_id = image_file_list.length - 1;
          console.log("Current: " + current_image_id);
          console.log("length: " + image_file_list.length);
        }else{
          current_image_id--;
          console.log("Current: " + current_image_id);
          console.log("length: " + image_file_list.length -1);
        }
        loadImage();
        if(workingfile){
          loadWorkingMeta();
        }else if(single_meta_file){
          loadMetaFileSingle();
        }else{
          loadMetaFiles();
        }
      }

      //Not finished will be included in future versions: load annotations if there is only one json file
      function loadAnnotationsSingle(){

      }

      // load annotations if there are multiple json files
      function loadAnnotations(){
        var results = [];
        var checkObject = document.getElementById("checked");
        if(current_image_id in unsavedChanges){
          var p = unsavedChanges[current_image_id]["people"];
          checkObject.innerHTML = "Yes";
        }else{
          var p = annotations["people"];
          if(!workingfile){
            checkObject.innerHTML = "No";
          }
        }
        //console.log(p);
        //save pose keypoints in results
        for(var i = 0; i < p.length; i++){
          var t = p[i]["pose_keypoints_2d"];
          //console.log(t);
          results.push(t);
        }
        console.log("Results:");
        console.log(results);
        //start disply for each pose
        for(var j= 0; j < results.length; j++){
          displayAnnotations(results[j], j);
        }
      }

      //prepare pose keypoints for display as svg
      function displayAnnotations(r, counter){
        var counter = counter;
        var points = [];

      //delete z variable (keypoint schema x,y,z with z = confidence level)
        for(var i = 0; i < r.length; i++){
          if((i+1) % 3 != 0){
            points.push(r[i]);
          }
        }

        //console.log("Points:");
        //console.log(points);

        var newpoints = {};
        for(var i = 0; i < points.length; i += 2){
            var id = i/2;
            newpoints[id] = [points[i], points[i+1]];
        }
        //console.log(newpoints);

        //set point schema for display
        bodyparts = {
          head1 : [newpoints[0], newpoints[15]],
          head2 : [newpoints[0], newpoints[16]],
          head3 : [newpoints[15], newpoints[17]],
          head4 : [newpoints[16], newpoints[18]],
          spine1: [newpoints[0], newpoints[1]],
          spine2: [newpoints[1], newpoints[8]],
          armL1 : [newpoints[1], newpoints[2]],
          armL2 : [newpoints[2], newpoints[3]],
          armL3 : [newpoints[3], newpoints[4]],
          armR1 : [newpoints[1], newpoints[5]],
          armR2 : [newpoints[5], newpoints[6]],
          armR3 : [newpoints[6], newpoints[7]],
          legL1 : [newpoints[8], newpoints[9]],
          legL2 : [newpoints[9], newpoints[10]],
          legL3 : [newpoints[10], newpoints[11]],
          legR1 : [newpoints[8], newpoints[12]],
          legR2 : [newpoints[12], newpoints[13]],
          legR3 : [newpoints[13], newpoints[14]],
          footL1: [newpoints[11], newpoints[22]],
          footL2: [newpoints[22], newpoints[23]],
          footL3: [newpoints[11], newpoints[24]],
          footR1: [newpoints[14], newpoints[19]],
          footR2: [newpoints[19], newpoints[20]],
          footR3: [newpoints[14], newpoints[21]]
        }
        //delete all points that have 0 value (if 0 bodypart is not assigned)
        for(var i in bodyparts){
          //console.log("id: " + i);
          if((bodyparts[i][0][0] == 0) || (bodyparts[i][1][1] == 0)){
            delete bodyparts[i];
          }
        }
        //console.log(bodyparts);

        //stringify point arrays and start line creation
        for(var id in bodyparts){
          if((bodyparts[id][0])&& (bodyparts[id][1])){
            var x1 = bodyparts[id][0][0].toString();
            var y1 = bodyparts[id][0][1].toString();
            var x2 = bodyparts[id][1][0].toString();
            var y2 = bodyparts[id][1][1].toString();
          }
          var idtemp = counter.toString() + " " + id.toString();
          createLine(x1, y1, x2, y2, idtemp);
        }

        for(var id in newpoints){
          var x = newpoints[id][0];
          var y = newpoints[id][1];
          var strx = x.toString();
          var stry = y.toString();
          //console.log(strx + " " + stry);
          var idtemp = counter.toString() + " " + id.toString();
          createPoint(strx, stry, idtemp);
        }
      }

      //creates a new svg point (circle) and sets all the attributes to the correct values
      function createPoint(x, y, id){
        var point = document.createElementNS(svgNS, "circle");
        var classes = color + " point";
        point.setAttributeNS(null,"cx", x);
        point.setAttributeNS(null, "cy", y);
        point.setAttributeNS(null, "r", "5");
        point.setAttributeNS(null, "class", classes);
        point.setAttributeNS(null,"id", id.toString());

        document.getElementById("svg").appendChild(point);
      }

      //creates a new svg line and sets all the attributes to the correct values
      function createLine(x1, y1, x2, y2, id){
        var line = document.createElementNS(svgNS, "line");
        line.setAttributeNS(null, "x1", x1);
        line.setAttributeNS(null, "y1", y1);
        line.setAttributeNS(null, "x2", x2);
        line.setAttributeNS(null, "y2", y2);
        line.setAttributeNS(null, "class", color);
        line.setAttributeNS(null, "id", id);
        line.setAttributeNS(null, "onload", "pointchange(evt)");

        document.getElementById("svg").appendChild(line);
      }

      //destroy all displayed svg elements
      function destroySvgEl(){
        var svg = document.getElementById("svg");
        while (svg.firstChild) {
          svg.removeChild(svg.lastChild);
        }
      }

      //Not finished will be included in future versions: prepare pose keypoints for display as svg if only one json file is given
      function displayAnnotationsSingle(r){
      }

      //change css class of svg elements to change appearance for the current and following annotations
      function changeAnnoColor(){
        var svg = document.getElementById("svg");
        if(color == "black"){
          color = "orange"
        }else{
          color ="black"
        }
        for(var i = 0; i < svg.childNodes.length; i++){
          svg.childNodes[i].style.stroke = color;
        }
      }

      //function for chaching the made changes
      function cacheAnnotations(){
        var svg = document.getElementById("svg");
        var children = svg.childNodes;
        var pointcounter = 0;


        for(var i = 0; i < children.length; i++){
          if(children[i].classList.contains("point")){

            var cx = children[i].getAttribute("cx");
            var cy = children[i].getAttribute("cy");

            // flatten the transformations made to the svg points to get new coordinates
            if(children[i].transform.baseVal.length != 0){
              var matrix = children[i].transform.baseVal.consolidate().matrix;
              var cache = svg.createSVGPoint();
              cache.x = cx;
              cache.y = cy;
              cache = cache.matrixTransform(matrix);
              var x = cache.x;
              var y = cache.y;
            }else{
              var x = cx;
              var y = cy;
            }

            //get Ids to save coordinates in the given schema and at the right index
            var pointId = children[i].getAttribute("id");
            var ids = pointId.split(" ");
            var pointschemaId = ids[1];
            var poseId = ids[0];
            //console.log("Ids: " + "point: " + pointschemaId + " pose: "+ poseId);

            var intPose = parseInt(poseId);
            var intId = parseInt(pointschemaId);
            var id1 = (intId * 2) + pointcounter;
            var id2 = id1 + 1;

            if(intId == 24){
              pointcounter = 0;
            }else{
              pointcounter++;
            }
            //console.log(intId, id1, id2);
            unsavedChanges[current_image_id] = Object.assign({}, annotations);
            //overwrite old coordinates with new ones
            unsavedChanges[current_image_id]["people"][poseId]["pose_keypoints_2d"][id1] = x;
            unsavedChanges[current_image_id]["people"][poseId]["pose_keypoints_2d"][id2] = y;
            unsavedChanges[current_image_id]["image_source"] = image_file_list[current_image_id];
            unsavedChanges[current_image_id]["meta_source"] = meta_id;
          }
        }

        console.log(unsavedChanges);
      }

      //reset all poses to the values from the original json file
      function resetPage (){
        disableModes();
        //overwrite cached annotations with the ones from json file
        unsavedChanges[current_image_id] = Object.assign({},annotations);
        destroySvgEl();
        loadAnnotations();
      }

      //enables/disables creation mode and sets color of poses to a different value for recognition
      function toggleCreationMode(on){
        var descr = document.getElementById("createDescr");
        disableModes("creationMode");
        var svg = document.getElementById("svg");
        if(on){
          creationMode = true;
          descr.style.display = "block";
          for(var i = 0; i < svg.childNodes.length; i++){
            svg.childNodes[i].setAttributeNS(null, "style", "stroke: green;");
          }
        }else{
          creationMode = false;

          if(highlighted){
            highlighted.removeAttribute("style");
            highlighted = null;
          }

          descr.style.display = "none";
          for(var i = 0; i < svg.childNodes.length; i++){
            svg.childNodes[i].removeAttributeNS(null, "style");
          }
          deleteDescr();
        }
      }

      //enables/disables reset mode and sets color of poses to a different value for recognition
      function toggleResetMode(on){
        disableModes("resetMode");
        var svg = document.getElementById("svg");
        if(on){
          resetMode = true;
          for(var i = 0; i < svg.childNodes.length; i++){
            svg.childNodes[i].setAttributeNS(null, "style", "stroke: purple;");
          }
        }else{
          resetMode = false;
          for(var i = 0; i < svg.childNodes.length; i++){
            svg.childNodes[i].removeAttributeNS(null, "style");
          }
        }
      }

      //enables/disables deletion mode and sets color of poses to a different value for recognition
      function toggleDeletionMode(on){
        disableModes("deletionMode");
        var svg = document.getElementById("svg");
        if(on){
          deletionMode = true;
          for(var i = 0; i < svg.childNodes.length; i++){
            svg.childNodes[i].setAttributeNS(null, "style", "stroke: red;");
          }
        }else{
          deletionMode = false;
          for(var i = 0; i < svg.childNodes.length; i++){
            svg.childNodes[i].removeAttributeNS(null, "style");
          }
        }
      }

      //deletes additional buttons for distinct bodyparts in the tool area added creation mode
      function deleteDescr(){
        var descr = document.getElementById("createDescr");
        for(var j = 1; j < descr.childNodes.length; j++){
          descr.childNodes[j].remove();
        }
      }



      async function exportUnfinished(){
        cacheAnnotations();
        var exportFile = [];
        var found = false;

        //checks if there are unsaved Changes
        if(unsavedChanges[0]){
          for(var i = 0; i < meta_file_list.length; i++){
            //checks if there are unsaved Changes in the current metadata-file
            for(var j in unsavedChanges){
              if(i == j){
                console.log("yay!");
                found = true;
                //save new metadata in the exportFile array
                exportFile[i] = Object.assign({}, unsavedChanges[j]);
                exportFile[i]["image_source"] = unsavedChanges[j]["image_source"].name;
                exportFile[i]["meta_source"] = unsavedChanges[j]["meta_source"].name;
                exportFile[i]["checked"] = true;
              }else{
                console.log("nay!");
              }
            }
            //current image has no changes yet
            if(found == false){
              console.log(1);
              var meta_name = meta_file_list[i].name;
              var id = meta_name.split("_")[0];

              //search for the image that belongs to the metadata
              var patt = new RegExp(id + ".");
              var imageTemp;

              for(var k = 0; k < image_file_list.length; k++){
                var d = image_file_list[k];
                if(patt.test(d.name)){
                  console.log(d);
                  imageTemp = d;
                }
              }
              //wait for the results of the file reading process
              var result = await readFileAsync(meta_file_list[i]);
              //parse current metadata file as json
              var a = JSON.parse(result);
              var annotationsTemp = $.extend(annotationsTemp,a);
              console.log(annotationsTemp);
              //save modulated metadata in exportFile array
              exportFile[i] = Object.assign({},annotationsTemp);
              exportFile[i]["image_source"] = imageTemp.name;
              exportFile[i]["meta_source"] = meta_name;
              exportFile[i]["checked"] = false;
            }
            found = false;
          }
          console.log(2)
          console.log("Export");
          console.log(exportFile);

          //set data for download file
          var filename = "poseannotatorFile.json";
          var text = JSON.stringify(exportFile);

          //start download
          download(filename, text);

        }else{
          alert("No Changes made!");
        }
      }

      //helper function to wrap file reading process in a promise that allows managing asynchronicity
      function readFileAsync(file){
        return new Promise((resolve, reject) => {
          let reader = new FileReader ();

          reader.onload = () => {
            resolve(reader.result);
          };

          reader.onerror = reject;

          reader.readAsText(file);
        })
      }

      //function for creating a html element that will trigger the download link and destroying the element afterwards
      function download(filename, text){
        var element = document.createElement("a");
        element.setAttribute("href", "data:text/plain;charset=utf-8," + encodeURIComponent(text));
        element.setAttribute("download", filename);

        element.style.display = "none";
        document.body.appendChild(element);

        element.click();

        document.body.removeChild(element);
      }

      function displayFileList(){
        fileview = document.getElementById("fileview");
        for(var i = 0; i < image_file_list.length; i++){
          var li = document.createElement("LI");
          li.innerHTML = "(" + String(i) + ") " + String(image_file_list[i].name);
          fileview.appendChild(li);
        }
      }
    </script>
  </body>
</html>
