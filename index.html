<!DOCTYPE html>
<html>
  <head>
    <title>Pose Annotator</title>
    <meta charset="UTF-8">
    <meta name="author" content="Cristian Ortega Singer">
    <script src="https://code.jquery.com/jquery-latest.js"></script>
    <!--import filsaver.js -->
    <script async="" src="https://cdn.rawgit.com/eligrey/FileSaver.js/5ed507ef8aa53d8ecfea96d96bc7214cd2476fd2/FileSaver.min.js"> </script>
    <!-- import jszip.js for zipping-->
    <script type="text/javascript" src="https://stuk.github.io/jszip/dist/jszip.min.js"></script>
    <style>
  div {/**border-style: dotted;**/}
      body {display: grid;}
      #header{
        grid-column: 1/span 3;
        grid-row: 1/ span 2;
      }
      #sidebar{
        grid-column: 1;
        grid-row: 2/span 7;
      }
      #workspace{
        grid-column: 2/span 3;
        grid-row: 2/span 5;
        grid-template-columns: max-content;
      }

      #footer{
        grid-column: 1/span 3;
        grid-row: 7;
      }

      .gridItem{display:grid;}

      #img-svg-wrap{
        position: relative;
        display: inline-block;
      }

      #image{
        display: absolute;
        max-width: 100%;
        min-width: 100%;
        height: auto;
      }

      #svg{
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
      }

      line{
        fill:none;
        stroke-width:3;
        stroke: black;
      }
      .black{
        stroke:black;
      }
      .orange{
        stroke:orange;
      }

      .point{
        stroke: black;
      }

      #createDescr, #poseDelButton{
        display:none;
      }

      #filescroll{
        width: 200px;
        height: 300px;
        overflow: scroll;
      }

      li{
        list-style-type: none;
      }
    </style>
  </head>
  <body>
    <div id="header" class="gridItem">
      Pose Annotator
      <form name="upload-metadata">
        <span>Metadata: </span>
        <input type="file" id="metadata" accept="application/json" multiple>
        </br>
        <span>Images: </span>
        <input type="file" id="images" accept="image/*" multiple>
        <button type="button" id="importButton" onclick="handleFiles();">Import Files</button>
        <input type="file" id="workingfile" accept="application/json">
        <button type="button" id="loadButton" onclick="handleWorkingFile();">Load Project </button>
        <button type="button" id="saveButton" onclick="exportUnfinished();">Save Project</button>
        <button type="button" id="exportButton" onclick="exportFinished();">Export Project</button>
      </form>
    </div>
    <div id="main" class="gridItem">
      <div id="sidebar" class="gridItem">
        Here are going to be all the tools and an overview of the images
          <p> Checked: <span id = "checked">No</span></p>
          <div id="files">
            <p>Images:<P>
            <div id="filescroll">
              <ul id="fileview"></ul>
            </div>
          </div>
        <div id="tools">Tools
          <button type="button" id="undoButton" onclick="resetPage();">Undo all Changes on this Image</button>
          <button type="button" id="resetButton" onclick="toggleResetMode(!resetMode);">Reset Mode</button>
          <button type="button" id="createButton" onclick="toggleCreationMode(!creationMode);">Creation Mode</button>
          <button type="button" id="deleteButton" onclick="toggleDeletionMode(!deletionMode);">Deletion Mode</button>
          <button type="button" id="selectButton" onclick="toggleSelectionMode(!selectionMode);">Selection Mode</button>
          <div id="optionsContainer">
            <div id="createDescr">
              <span> Possible Points to add (klick on joint where a part of the pose is missing):</span> </br>
            </div>
            <div id="poseDelDescr">
              <button type="button" id="poseDelButton" onclick="deletePose();" disabled = true>Delete Pose</button>
            </div>
          </div>
        </div>
        <div id="files">Files</div>
        <div id="arrows">
          <button type="button" id="lastPic" onclick="previousImage();">Prev</button>
          <button type="button" id="nextPic" onclick="nextImage();">Next</button>
        </div>
      </div>
      <div id="workspace" class="gridItem">
        <div id="img-svg-wrap">
          <img x= 0 y= 0 id="image" href="" alt="current Picture">
          <svg id="svg" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" onload="draggable(evt)">

          </svg>
        </div>
      </div>
    </div>
    <div id="footer" class="gridItem">
      Footer
    </div>

    <script type="text/javascript">
    "use strict";

    //initializing variables
      var IMG_FILEPATH = "img/";
      var META_FILEPATH = "metadata/";
      var single_meta_file = false;
      var working_file = false;
      var meta_file_list = {};
      var annotations;
      var image_file_list = {};
      var current_image_id;
      var current_image_source;
      var meta_id;
      var unsavedChanges = {};

      var fileview;

      var working_file_list = {};
      var working_data = {};

      var selectedPoseElements = [];

      var color = "black";
      var resetMode = false;
      var creationMode = false;
      var deletionMode = false;
      var selectionMode = false;

      var bodyparts = {};

      var bodyschema = {
        "head1" : [0, 15],
        "head2" : [0, 16],
        "head3" : [15, 17],
        "head4" : [16, 18],
        "spine1": [0, 1],
        "spine2": [1, 8],
        "armL1" : [1, 2],
        "armL2" : [2, 3],
        "armL3" : [3, 4],
        "armR1" : [1, 5],
        "armR2" : [5, 6],
        "armR3" : [6, 7],
        "legL1" : [8, 9],
        "legL2" : [9, 10],
        "legL3" : [10, 11],
        "legR1" : [8, 12],
        "legR2" : [12, 13],
        "legR3" : [13, 14],
        "footL1": [11, 22],
        "footL2": [22, 23],
        "footL3": [11, 24],
        "footR1": [14, 19],
        "footR2": [19, 20],
        "footR3": [14, 21]
      };

      var highlighted;
      var creating;
      var creationPoint;
      var selectedElement;
      var offset;
      var transform;
      var bbox;
      var minX;
      var minY;
      var maxX;
      var maxY;
      var boundaryX1 = 0;
      var boundaryY1 = 0;
      var boundaryX2 = document.getElementById("svg").width;
      var boundaryY2 = document.getElementById("svg").height;
      var svgNS = "http://www.w3.org/2000/svg";


      // Check for the various File API support.
      if (!window.File || !window.FileReader || !window.FileList || !window.Blob) {
        alert("The File APIs are not fully supported in this browser.");
      }

      //various event listeners for tracking key and mouse navigation
      document.addEventListener("keydown", function(event) {
        if(event.keyCode == 37) {
          console.log("Left was pressed");
          previousImage();
        }
        else if(event.keyCode == 39) {
          console.log("Right was pressed");
          nextImage();
        }
        else if(event.keyCode == 40) {
          console.log("Down was pressed");
          changeAnnoColor();
        }
        else if(event.keyCode == 68){
          console.log("d was pressed");
          toggleDeletionMode(!deletionMode);
        }else if(event.keyCode == 67){
          console.log("c was pressed");
          toggleCreationMode(!creationMode);
        }else if(event.keyCode == 82){
          console.log("r was pressed");
          toggleResetMode(!resetMode);
        }else if(event.keyCode == 83){
          console.log("s was pressed");
          toggleSelectionMode(!selectionMode);
        }
      });

      //function for making the annotation points draggable
      function draggable(evt){
        var svg = evt.target;

        //set event listeners for mouse movement
        svg.addEventListener("mousedown", function(event){
          if(creating){
            creating = false;
            endDrag(event);
          }else if(resetMode){
            undoChanges(event);
          }else if(creationMode){
            addAnnotation(event);
          }else if(deletionMode){
            deletePoint(event);
          }else if(selectionMode){
            selectPose(event);
          }else{
            startDrag(event);
          }
        });
        svg.addEventListener("mousedown", startDrag);
        svg.addEventListener("mousemove", drag);
        svg.addEventListener("mouseup", endDrag);
        svg.addEventListener("mouseleave", endDrag);

        //currently not working! function for adding new points to an uncomplete bodyschema
        function addAnnotation(evt){
          let descr = document.getElementById("createDescr");
          let svg = document.getElementById("svg");
          let children = svg.childNodes;
          if(evt.target.classList.contains("point")){
            if(highlighted){
              highlighted.removeAttribute("style");
              deleteDescr();
            }
            selectedElement = evt.target;
            highlighted = selectedElement;
            selectedElement.setAttributeNS(null, "style", "fill: red;")
            let pointId = selectedElement.getAttribute("id");
            let ids = pointId.split(" ");
            let pointschemaId = ids[1];
            let poseId = ids[0];

            for(let i in bodyschema){
              if(bodyschema[i][0] == pointschemaId){
                //console.log(bodyschema[i]);
                for(let j = 0; j < children.length; j++){
                  if(children[j].classList.contains("point")){
                    let pointId2 = children[j].getAttribute("id");
                    let ids2 = pointId2.split(" ");
                    if((ids2[1] == bodyschema[i][1]) && (ids2[0] == ids[0])){
                      console.log(children[j].getAttribute("cx"));
                      let xTemp = parseInt(children[j].getAttribute("cx"));
                      let yTemp = parseInt(children[j].getAttribute("cy"));
                      if((xTemp == "0") && (yTemp == "0")){
                        console.log(xTemp, yTemp);
                        console.log(i);
                        let btn = document.createElement("BUTTON");
                        btn.innerHTML = i;
                        btn.setAttribute("pointId", pointId);
                        btn.setAttribute("onclick", "fireButton(this);")
                        descr.appendChild(btn);
                        console.log(pointId);
                      }
                    }
                  }
                }
              }
            }
          }
        }

        //set coordinates of selected point back to default
        function undoChanges(evt){
          if(evt.target.classList.contains("point")){
            selectedElement = evt.target;
            if(selectedElement.hasAttributeNS(null,"transform")){
              selectedElement.removeAttributeNS(null, "transform");

              let lineIds = getLineIds();

              let x = selectedElement.getAttributeNS(null, "cx");
              let y = selectedElement.getAttributeNS(null, "cy");
              for(let k in lineIds){
                //console.log(k);
                let line = document.getElementById(k.toString());

                if(line){
                  if(lineIds[k] == 0){
                    line.setAttributeNS(null,"x1", x);
                    line.setAttributeNS(null,"y1", y);
                    //console.log("changed x1 and y1");
                  }else if(lineIds[k] == 1){
                    line.setAttributeNS(null,"x2", x);
                    line.setAttributeNS(null,"y2", y);
                    //console.log("changed x2 and y2");
                  }else{
                    console.log("An error occured. Look in source code function undoChanges() to see what happened.");
                  }
                }
              }
            }
          }
        }

        //Delete parts of the pose
        function deletePoint(evt){
          console.log("Point Deletion");

          if(evt.target.classList.contains("point")){
            selectedElement = evt.target;
            //removes transformations if they exist
            if(selectedElement.hasAttributeNS(null,"transform")){
              selectedElement.removeAttributeNS(null, "transform");
              //sets coordinates of point to 0
              selectedElement.setAttributeNS(null, "cx", 0);
              selectedElement.setAttributeNS(null, "cy", 0);

              //get all lines that connect to point
              let lineIds = getLineIds();
              //delete all connected lines
              for(let k in lineIds){
                //console.log(k);
                let line = document.getElementById(k.toString());
                if(line){
                  line.remove();
                }
              }
            }
          }
        }

        function selectPose(evt){
          console.log("Select Pose Start");
          selectedPoseElements = [];
          if(evt.target.classList.contains("point")){
            selectedElement = evt.target;

            let pointId = selectedElement.getAttribute("id");
            let ids = pointId.split(" ");
            let pointschemaId = ids[1];
            let poseId = ids[0];

            let svg = document.getElementById("svg");

            for(let i = 0; i < svg.children.length; i++){
              let tempElementId = svg.children[i].getAttribute("id");
              let idsTemp = tempElementId.split(" ");
              if(poseId == idsTemp[0]){
                selectedPoseElements.push(svg.children[i]);
                svg.children[i].setAttributeNS(null, "style", "stroke: blue;");
              }else{
                svg.children[i].removeAttributeNS(null, "style");
              }
            }
            if(selectedPoseElements){
                console.log(selectedPoseElements);
                let btn = document.getElementById("poseDelButton");
                btn.disabled = false;
            }else{
              console.log("An Error occured. Please look at function selectPose(evt) in code.");
            }
          }
        }

        //track mouseposition on screen if mouse interacts with svg
        function getMousePos(evt){
          let ctm = svg.getScreenCTM();
          if(evt.touches){
            evt = evt.touches[0];
          }
          return{
            x: (evt.clientX - ctm.e) / ctm.a,
            y: (evt.clientY - ctm.f) / ctm.d
          };
        }

        // handles mousedown event, starts dragging process
        function startDrag(evt){
          let svgtemp = document.getElementById("svg");

          //set boundaries to Imagesize so that it is impossible to drag points out of view
          boundaryX2 = svgtemp.width.baseVal.value;
          boundaryY2 = svgtemp.height.baseVal.value;

          //console.log("Boundaries:");
          //console.log(boundaryX2);
          //console.log(boundaryY2);

          //correct mouse offset in relation to svg through a transformation
          if(evt.target.classList.contains("point")){
            selectedElement = evt.target;
            offset = getMousePos(evt);
            //console.log(offset);

            let transforms = selectedElement.transform.baseVal;

            if(transforms.length === 0 || transforms.getItem(0).type !== SVGTransform.SVG_TRANSFORM_TRANSLATE){
              let translate = svg.createSVGTransform();
              translate.setTranslate(0,0);
              selectedElement.transform.baseVal.insertItemBefore(translate,0);
            }

            transform = transforms.getItem(0);
            offset.x -= transform.matrix.e;
            offset.y -= transform.matrix.f;

            //console.log(offset.x);
            //console.log(offset.y);

            //set boundaries according to the collision box of svg element
            bbox = selectedElement.getBBox();
            minX = boundaryX1 - bbox.x;
            maxX = boundaryX2 -bbox.x - bbox.width;
            minY = boundaryY1 - bbox.y;
            maxY = boundaryY2 - bbox.y - bbox.height;
          }
        }

        //handles mousemove event; the dragging process itself
        function drag(evt){
          if(selectedElement){
            evt.preventDefault();
            let coord = getMousePos(evt);
            let dx = coord.x - offset.x;
            let dy = coord.y - offset.y;

            //make shure svg element stays within boundaries
            if(dx < minX){
              dx = minX;
            }else if(dx >maxX){
              dx = maxX;
            }

            if(dy < minY){
              dy = minY;
            }else if(dy > maxY){
              dy = maxY;
            }
            //set new position for svg point
            transform.setTranslate(dx, dy);
            let lineIds = getLineIds();

            for(let k in lineIds){
              //console.log(k);
              let line = document.getElementById(k.toString());

              if(line){
                if(lineIds[k] == 0){
                  line.setAttributeNS(null,"x1", coord.x);
                  line.setAttributeNS(null,"y1", coord.y);
                  //console.log("changed x1 and y1");
                }else if(lineIds[k] == 1){
                  line.setAttributeNS(null,"x2", coord.x);
                  line.setAttributeNS(null,"y2", coord.y);
                  //console.log("changed x2 and y2");
                }else{
                  console.log("An error occured. Look in source code function pointchange() to see what happened.");
                }
              }
            }
          }
        }

        //set new position for svg lines if selected point is one of the coordinates
        function getLineIds(){
          //get point id and bodyschema ids for identifing correct lines
          let pointId = selectedElement.getAttribute("id");
          let ids = pointId.split(" ");
          let pointschemaId = ids[1];
          let poseId = ids[0];
          //console.log("Pointschema Id: " + pointschemaId);
          let lineIds = {};
          //get all bodyparts that have the right identifier
          for(let i in bodyschema){
            for(let j = 0; j < bodyschema[i].length; j++){
              if(bodyschema[i][j] == pointschemaId){
                lineIds[poseId + " " + i] = j;
              }
            }
          }
          return lineIds;
        }

        //handles mouseup and mouseleave events; stops dragging process
        function endDrag (evt){
          selectedElement = false;
        }
      }
      //currently not working a failed try to create points of specific bodyparts
      function fireButton(btn){
        console.log("fired Button event");
        let pointId = btn.getAttribute("pointId");
        let point = document.getElementById(pointId);

        let eventDown = new MouseEvent("mousedown");
        point.dispatchEvent(eventDown);
        let eventMove = new MouseEvent("mousemove");
      }

        //Not finished will be included in future versions: load json file if the annotations are saved in only one json file
      function loadMetaFileSingle(){

      }

      //load current json file if the annotations are saved in multiple json files
      function loadMetaFiles(){
        single_meta_file = false;

        //console.log(meta_file_list);

        //get name of json file through the name of the image file
        let id = current_image_source.split(".")[0];
        //create a new regex pattern
        let patt = new RegExp(id + "_");

        //console.log(id);
        //search in loaded meta files for the correct file via file name and save file in meta_id
        for(let i = 0; i < meta_file_list.length; i++){
          let d = meta_file_list[i];
          if(patt.test(d.name)){
            //console.log(d);
            meta_id = d;
          }
        }

        //if file found launch a file reader to get content of file as a string array
        if(meta_id){
          let reader = new FileReader();
          reader.onload = getAnnotations;
          //console.log(meta_id);
          reader.readAsText(meta_id);
        }

        function getAnnotations(t, callback = function(){loadAnnotations();}){
          //console.log(callback);
          let lines = t.target.result;
          let a = JSON.parse(lines);
          annotations = $.extend(annotations,a);
          //console.log("Annotations:");
          //console.log(annotations);
          callback();
        }
      }

      //initiate the file reading process of json and image files
      function handleFiles(){
        workingfile = false;
        //get json and image files from the file selector
        image_file_list = document.getElementById("images").files;
        meta_file_list = document.getElementById("metadata").files;

        displayFileList();
        //catching errors
        if(!image_file_list[0]){
          alert("You have to select image files before you can continue!");
        }else if(!meta_file_list[0]){
          alert("You have to select JSON files before you can continue!");
        }else if(image_file_list[0] && meta_file_list[0]){
          console.log(image_file_list);
          console.log(meta_file_list);
          if(annotations){
            if(confirm("Annotations already included! Unsaved changes will be lost! Do you want to replace annotation File(s)?")){
              current_image_id = 0;
              loadImage();
              annotations = {};
              unsavedChanges = {};
              if(meta_file_list.length > 1){
                loadMetaFiles();
              }else{
                loadMetaFileSingle();
              }
            }
          }else{
            current_image_id = 0;
            loadImage();
            annotations = {};
            unsavedChanges = {};
            //check if there are multiple json files or just one
            if(meta_file_list.length > 1){
              loadMetaFiles();
            }else{
              loadMetaFileSingle();
            }
          }
        }
      }

      //display image
      function loadImage(){
        destroySvgEl();
        let currentFileLink = document.getElementById(String(current_image_id) + "_link");
        currentFileLink.style.color = "red";

        if(!image_file_list[current_image_id]){
          //console.log(current_image_id);
          alert("An Error occured! No Image Id found.")
        }else{
          let imag = document.getElementById("image");
          current_image_source = image_file_list[current_image_id].name;

          if(imag.complete){
            let new_image = new Image();
            new_image.id = "image";
            new_image.src = IMG_FILEPATH + current_image_source;
            imag.parentNode.insertBefore(new_image, imag);
            imag.parentNode.removeChild(imag);
          }
        }
      }

      function handleWorkingFile(){
        workingfile = true;
        single_meta_file = false;
        working_file_list = document.getElementById("workingfile").files;
        if(!working_file_list[0]){
          alert("You have to select a project to load before you can continue!");
        }else{
          console.log(working_file_list);
          if(annotations){
            if(confirm("Annotations already included! Unsaved changes will be lost! Do you want to replace annotation File(s)?")){
              readWorkingFile();
            }
          }else{
            readWorkingFile();
          }
        }

        function readWorkingFile(){
          current_image_id = 0;
          annotations = {};
          unsavedChanges = {};

          let reader = new FileReader();
          reader.onload = getAnnotations;
          console.log(working_file_list[0]);
          reader.readAsText(working_file_list[0]);
          console.log(reader.readyState);

          function getAnnotations(t, callback = function(){
              console.log("Working Data:");
              console.log(working_data);
              let imageListTemp = [];
              let metaListTemp = [];
              for(let i in working_data){
                imageListTemp[i] = {"name" : working_data[i].image_source};
                metaListTemp[i] = {"name" : working_data[i].meta_source};
              }
              image_file_list = imageListTemp.slice();
              meta_file_list = metaListTemp.slice();
              /**image_file_list = Object.assign({}, imageListTemp);
              meta_file_list = Object.assign({}, metaListTemp);**/
              console.log(image_file_list);
              console.log(meta_file_list);

              displayFileList();
              loadImage();
              loadWorkingMeta();
            }){
            //console.log(callback);
            let lines = t.target.result;
            let a = JSON.parse(lines);
            working_data = $.extend(working_data,a);
            callback();
          }
        }
      }

      function loadWorkingMeta(){
        let checkObject = document.getElementById("checked");

        for(let i in working_data){
          if(current_image_source == working_data[i].image_source){
            annotations["people"] = Object.values(working_data[i].people);
            if(working_data[i].checked == true){
              checkObject.innerHTML = "Yes";
            }else{
              checkObject.innerHTML = "No";
            }
            console.log("Annotations:");
            console.log(annotations);
            loadAnnotations();
          }
        }
      }

      //disables all modes (optional leave current mode on)
      function disableModes(current = ""){
        if(current == "resetMode"){
          creationMode = false;
          deletionMode = false;
          selectionMode = false;
        }else if(current == "deletionMode"){
          creationMode = false;
          resetMode = false;
          selectionMode = false;
        }else if(current == "creationMode"){
          resetMode = false;
          deletionMode = false;
          selectionMode = false;
        }else if(current == "selectionMode"){
          creationMode = false;
          resetMode = false;
          deletionMode = false;
        }else{
          creationMode = false;
          resetMode = false;
          deletionMode = false;
          selectionMode = false;
          let currentFileLink = document.getElementById(String(current_image_id) + "_link");
          currentFileLink.style.color = "";
        }
      }

      //function for loading next image with annotations
      function nextImage(){
        disableModes();
        deleteDescr();
        cacheAnnotations();
        if(current_image_id >= image_file_list.length -1){
          current_image_id = 0;
        }else{
          current_image_id++;
        }
        loadImage();
        if(workingfile){
          loadWorkingMeta();
        }else if(single_meta_file){
          loadMetaFileSingle();
        }else{
          loadMetaFiles();
        }
      }

      //function for loading previous image with annotations
      function previousImage(){
        disableModes();
        deleteDescr();
        cacheAnnotations();
        if(current_image_id <= 0){
          current_image_id = image_file_list.length - 1;
          console.log("Current: " + current_image_id);
          console.log("length: " + image_file_list.length);
        }else{
          current_image_id--;
          console.log("Current: " + current_image_id);
          console.log("length: " + image_file_list.length -1);
        }
        loadImage();
        if(workingfile){
          loadWorkingMeta();
        }else if(single_meta_file){
          loadMetaFileSingle();
        }else{
          loadMetaFiles();
        }
      }

      function specificImage(id){
        disableModes();
        deleteDescr();
        cacheAnnotations();
        if((id < image_file_list.length) && (id >= 0)){
          current_image_id = id;
        }else{
          alert("An Error occured! Look in code function 'specificImage(id)'");
        }
        loadImage();
        if(workingfile){
          loadWorkingMeta();
        }else if(single_meta_file){
          loadMetaFileSingle();
        }else{
          loadMetaFiles();
        }
      }
      //Not finished will be included in future versions: load annotations if there is only one json file
      function loadAnnotationsSingle(){

      }

      // load annotations if there are multiple json files
      function loadAnnotations(){
        let results = [];
        let p;
        let checkObject = document.getElementById("checked");
        if(current_image_id in unsavedChanges){
          p = unsavedChanges[current_image_id]["people"];
          checkObject.innerHTML = "Yes";
        }else{
          p = annotations["people"];
          if(!workingfile){
            checkObject.innerHTML = "No";
          }
        }
        //console.log(p);
        //save pose keypoints in results
        for(let i = 0; i < p.length; i++){
          let t = p[i]["pose_keypoints_2d"];
          //console.log(t);
          results.push(t);
        }
        console.log("Results:");
        console.log(results);
        //start disply for each pose
        for(let j= 0; j < results.length; j++){
          displayAnnotations(results[j], j);
        }
      }

      //prepare pose keypoints for display as svg
      function displayAnnotations(r, c){
        let counter = c;
        let points = [];

      //delete z letiable (keypoint schema x,y,z with z = confidence level)
        for(let i = 0; i < r.length; i++){
          if((i+1) % 3 != 0){
            points.push(r[i]);
          }
        }

        //console.log("Points:");
        //console.log(points);

        let newpoints = {};
        for(let i = 0; i < points.length; i += 2){
            let id = i/2;
            newpoints[id] = [points[i], points[i+1]];
        }
        //console.log(newpoints);

        //set point schema for display
        bodyparts = {
          head1 : [newpoints[0], newpoints[15]],
          head2 : [newpoints[0], newpoints[16]],
          head3 : [newpoints[15], newpoints[17]],
          head4 : [newpoints[16], newpoints[18]],
          spine1: [newpoints[0], newpoints[1]],
          spine2: [newpoints[1], newpoints[8]],
          armL1 : [newpoints[1], newpoints[2]],
          armL2 : [newpoints[2], newpoints[3]],
          armL3 : [newpoints[3], newpoints[4]],
          armR1 : [newpoints[1], newpoints[5]],
          armR2 : [newpoints[5], newpoints[6]],
          armR3 : [newpoints[6], newpoints[7]],
          legL1 : [newpoints[8], newpoints[9]],
          legL2 : [newpoints[9], newpoints[10]],
          legL3 : [newpoints[10], newpoints[11]],
          legR1 : [newpoints[8], newpoints[12]],
          legR2 : [newpoints[12], newpoints[13]],
          legR3 : [newpoints[13], newpoints[14]],
          footL1: [newpoints[11], newpoints[22]],
          footL2: [newpoints[22], newpoints[23]],
          footL3: [newpoints[11], newpoints[24]],
          footR1: [newpoints[14], newpoints[19]],
          footR2: [newpoints[19], newpoints[20]],
          footR3: [newpoints[14], newpoints[21]]
        }
        //delete all points that have 0 value (if 0 bodypart is not assigned)
        for(let i in bodyparts){
          //console.log("id: " + i);
          if((bodyparts[i][0][0] == 0) || (bodyparts[i][1][1] == 0)){
            delete bodyparts[i];
          }
        }
        //console.log(bodyparts);

        //stringify point arrays and start line creation
        let x1;
        let y1;
        let x2;
        let y2;
        for(let id in bodyparts){
          if((bodyparts[id][0])&& (bodyparts[id][1])){
            x1 = bodyparts[id][0][0].toString();
            y1 = bodyparts[id][0][1].toString();
            x2 = bodyparts[id][1][0].toString();
            y2 = bodyparts[id][1][1].toString();
          }
          let idtemp = counter.toString() + " " + id.toString();
          createLine(x1, y1, x2, y2, idtemp);
        }

        for(let id in newpoints){
          let x = newpoints[id][0];
          let y = newpoints[id][1];
          let strx = x.toString();
          let stry = y.toString();
          //console.log(strx + " " + stry);
          let idtemp = counter.toString() + " " + id.toString();
          createPoint(strx, stry, idtemp);
        }
      }

      //creates a new svg point (circle) and sets all the attributes to the correct values
      function createPoint(x, y, id){
        let point = document.createElementNS(svgNS, "circle");
        let classes = color + " point";
        point.setAttributeNS(null,"cx", x);
        point.setAttributeNS(null, "cy", y);
        point.setAttributeNS(null, "r", "5");
        point.setAttributeNS(null, "class", classes);
        point.setAttributeNS(null,"id", id.toString());

        document.getElementById("svg").appendChild(point);
      }

      //creates a new svg line and sets all the attributes to the correct values
      function createLine(x1, y1, x2, y2, id){
        let line = document.createElementNS(svgNS, "line");
        line.setAttributeNS(null, "x1", x1);
        line.setAttributeNS(null, "y1", y1);
        line.setAttributeNS(null, "x2", x2);
        line.setAttributeNS(null, "y2", y2);
        line.setAttributeNS(null, "class", color);
        line.setAttributeNS(null, "id", id);
        line.setAttributeNS(null, "onload", "pointchange(evt)");

        document.getElementById("svg").appendChild(line);
      }

      //destroy all displayed svg elements
      function destroySvgEl(){
        let svg = document.getElementById("svg");
        while (svg.firstChild) {
          svg.removeChild(svg.lastChild);
        }
      }

      //Not finished will be included in future versions: prepare pose keypoints for display as svg if only one json file is given
      function displayAnnotationsSingle(r){
      }

      //change css class of svg elements to change appearance for the current and following annotations
      function changeAnnoColor(){
        let svg = document.getElementById("svg");
        if(color == "black"){
          color = "orange"
        }else{
          color ="black"
        }
        for(let i = 0; i < svg.childNodes.length; i++){
          svg.childNodes[i].style.stroke = color;
        }
      }

      //function for chaching the made changes
      function cacheAnnotations(){
        let svg = document.getElementById("svg");
        let children = svg.childNodes;
        let pointcounter = 0;
        let x;
        let y;
        let cx;
        let cy;

        for(let i = 0; i < children.length; i++){
          if(children[i].classList.contains("point")){

            cx = children[i].getAttribute("cx");
            cy = children[i].getAttribute("cy");

            // flatten the transformations made to the svg points to get new coordinates
            if(children[i].transform.baseVal.length != 0){
              let matrix = children[i].transform.baseVal.consolidate().matrix;
              let cache = svg.createSVGPoint();
              cache.x = cx;
              cache.y = cy;
              cache = cache.matrixTransform(matrix);
              x = cache.x;
              y = cache.y;
            }else{
              x = cx;
              y = cy;
            }

            //get Ids to save coordinates in the given schema and at the right index
            let pointId = children[i].getAttribute("id");
            let ids = pointId.split(" ");
            let pointschemaId = ids[1];
            let poseId = ids[0];
            //console.log("Ids: " + "point: " + pointschemaId + " pose: "+ poseId);

            let intPose = parseInt(poseId);
            let intId = parseInt(pointschemaId);
            let id1 = (intId * 2) + pointcounter;
            let id2 = id1 + 1;

            if(intId == 24){
              pointcounter = 0;
            }else{
              pointcounter++;
            }
            //console.log(intId, id1, id2);
            unsavedChanges[current_image_id] = Object.assign({}, annotations);
            //overwrite old coordinates with new ones
            unsavedChanges[current_image_id]["people"][poseId]["pose_keypoints_2d"][id1] = x;
            unsavedChanges[current_image_id]["people"][poseId]["pose_keypoints_2d"][id2] = y;
            unsavedChanges[current_image_id]["image_source"] = image_file_list[current_image_id];
            unsavedChanges[current_image_id]["meta_source"] = meta_id;
          }
        }

        console.log(unsavedChanges);
      }

      //reset all poses to the values from the original json file
      function resetPage (){
        disableModes();
        //overwrite cached annotations with the ones from json file
        unsavedChanges[current_image_id] = Object.assign({},annotations);
        destroySvgEl();
        loadAnnotations();
      }

      //enables/disables creation mode and sets color of poses to a different value for recognition
      function toggleCreationMode(on){
        let descr = document.getElementById("createDescr");
        disableModes("creationMode");
        let svg = document.getElementById("svg");
        if(on){
          creationMode = true;
          descr.style.display = "block";
          for(let i = 0; i < svg.childNodes.length; i++){
            svg.childNodes[i].setAttributeNS(null, "style", "stroke: green;");
          }
        }else{
          creationMode = false;

          if(highlighted){
            highlighted.removeAttribute("style");
            highlighted = null;
          }

          descr.style.display = "none";
          for(let i = 0; i < svg.childNodes.length; i++){
            svg.childNodes[i].removeAttributeNS(null, "style");
          }
          deleteDescr();
        }
      }

      //enables/disables reset mode and sets color of poses to a different value for recognition
      function toggleResetMode(on){
        disableModes("resetMode");
        let svg = document.getElementById("svg");
        if(on){
          resetMode = true;
          for(let i = 0; i < svg.childNodes.length; i++){
            svg.childNodes[i].setAttributeNS(null, "style", "stroke: purple;");
          }
        }else{
          resetMode = false;
          for(let i = 0; i < svg.childNodes.length; i++){
            svg.childNodes[i].removeAttributeNS(null, "style");
          }
        }
      }

      //enables/disables deletion mode and sets color of poses to a different value for recognition
      function toggleDeletionMode(on){
        disableModes("deletionMode");
        let svg = document.getElementById("svg");
        if(on){
          deletionMode = true;
          for(let i = 0; i < svg.childNodes.length; i++){
            svg.childNodes[i].setAttributeNS(null, "style", "stroke: red;");
          }
        }else{
          deletionMode = false;
          for(let i = 0; i < svg.childNodes.length; i++){
            svg.childNodes[i].removeAttributeNS(null, "style");
          }
        }
      }

      function toggleSelectionMode(on){
        disableModes("selectionMode");
        let svg = document.getElementById("svg");
        let delBtn = document.getElementById("poseDelButton");
        if(on){
          selectionMode = true;
          for(let i = 0; i < svg.childNodes.length; i++){
            svg.childNodes[i].setAttributeNS(null, "style", "stroke: blue;");
          }
          delBtn.style.display = "block";
          delBtn.disabled = true;
        }else{
          selectionMode = false;
          delBtn.disabled = true;
          delBtn.style.display = "none";
          for(let i = 0; i < svg.childNodes.length; i++){
            svg.childNodes[i].removeAttributeNS(null, "style");
          }
        }
      }

      //deletes additional buttons for distinct bodyparts in the tool area added creation mode
      function deleteDescr(){
        let descr = document.getElementById("createDescr");
        for(let j = 1; j < descr.childNodes.length; j++){
          descr.childNodes[j].remove();
        }
      }

      //function for creating and downloading a working file with already made changes
      async function exportUnfinished(){
        //save changes on current picture
        cacheAnnotations();

        let exportFile = [];
        let found = false;

        //checks if there are unsaved Changes
        if(unsavedChanges[0]){
          for(let i = 0; i < meta_file_list.length; i++){
            //checks if there are unsaved Changes in the current metadata-file
            for(let j in unsavedChanges){
              if(i == j){
                found = true;
                //save new metadata in the exportFile array
                exportFile[i] = Object.assign({}, unsavedChanges[j]);
                exportFile[i]["image_source"] = unsavedChanges[j]["image_source"].name;
                exportFile[i]["meta_source"] = unsavedChanges[j]["meta_source"].name;
                exportFile[i]["checked"] = true;
              }
            }
            //current image has no changes yet
            if(found == false){
              let meta_name = meta_file_list[i].name;
              let id = meta_name.split("_")[0];

              //search for the image that belongs to the metadata
              let patt = new RegExp(id + ".");
              let imageTemp;

              for(let k = 0; k < image_file_list.length; k++){
                let d = image_file_list[k];
                if(patt.test(d.name)){
                  console.log(d);
                  imageTemp = d;
                }
              }
              //wait for the results of the file reading process
              let result = await readFileAsync(meta_file_list[i]);
              //parse current metadata file as json
              let a = JSON.parse(result);
              let annotationsTemp = $.extend(annotationsTemp,a);
              console.log(annotationsTemp);
              //save modulated metadata in exportFile array
              exportFile[i] = Object.assign({},annotationsTemp);
              exportFile[i]["image_source"] = imageTemp.name;
              exportFile[i]["meta_source"] = meta_name;
              exportFile[i]["checked"] = false;
            }
            found = false;
          }
          console.log("Export");
          console.log(exportFile);

          //set data for download file
          let filename = "poseannotatorFile.json";
          let text = JSON.stringify(exportFile);

          //start download
          download(filename, text);

        }else{
          alert("No Changes made!");
        }
      }

      //function for creating and downloading a zip file with all updated json files
      async function exportFinished(){
        //save changes on current picture
        cacheAnnotations();

        let exportFile = [];
        let found = false;

        //checks if there are unsaved Changes
        if(unsavedChanges[0]){
          for(let i = 0; i < meta_file_list.length; i++){
            //checks if there are unsaved Changes in the current metadata-file
            for(let j in unsavedChanges){
              if(i == j){
                found = true;

                let result = await readFileAsync(meta_file_list[i]);
                //parse current metadata file as json
                let a = JSON.parse(result);
                //overwrite metadata with unsavedChanges
                a["people"] = unsavedChanges[j]["people"];

                exportFile[i] = Object.assign({}, a);
              }
            }
            //current image has no changes yet
            if(found == false){
              //wait for the results of the file reading process
              let result = await readFileAsync(meta_file_list[i]);
              //parse current metadata file as json
              let a = JSON.parse(result);
              //save metadata in exportFile array
              exportFile[i] = Object.assign({},a);
            }
            found = false;
          }
          console.log("Export");
          console.log(exportFile);

          //create zip element
          let zip = new JSZip();

          //add all metadata files to zip element
          for(let i = 0; i < exportFile.length; i++){
            let text = JSON.stringify(exportFile[i]);
            let filename = meta_file_list[i]["name"];
            zip.file(filename, text);
          }

          //generate zip file and download it
          zip.generateAsync({type:"blob"}).then(function(blob){
            console.log(zip);
            saveAs(blob, "pa-export-files.zip");
          }, function (err){
            console.log("Error in zipping");
          });

        }else{
          alert("No Changes made!");
        }
      }

      //helper function to wrap file reading process in a promise that allows managing asynchronicity
      function readFileAsync(file){
        return new Promise((resolve, reject) => {
          let reader = new FileReader ();

          reader.onload = () => {
            resolve(reader.result);
          };

          reader.onerror = reject;

          reader.readAsText(file);
        })
      }

      //function for creating a html element that will trigger the download link and destroying the element afterwards
      function download(filename, text){
        let element = document.createElement("A");
        element.setAttribute("href", "data:text/plain;charset=utf-8," + encodeURIComponent(text));
        element.setAttribute("download", filename);

        element.style.display = "none";
        document.body.appendChild(element);

        element.click();

        document.body.removeChild(element);
      }

      //function for display of file names in tool bar
      function displayFileList(){
        fileview = document.getElementById("fileview");
        for(let i = 0; i < image_file_list.length; i++){
          let li = document.createElement("LI");
          let a = document.createElement("A");
          a.setAttribute("href", "javascript:specificImage(" + String(i) + ");");
          a.setAttribute("id", String(i) + "_link");
          a.innerHTML = "(" + String(i + 1) + ") " + String(image_file_list[i].name);
          li.appendChild(a);
          fileview.appendChild(li);
        }
      }

      function deletePose(){
        if(confirm("Are you shure you want to delete this pose? You cannot undo this step.")){
          cacheAnnotations();
          console.log("Selected Pose Elements:");
          console.log(selectedPoseElements);
          let elId = selectedPoseElements[0].getAttributeNS(null, "id");
          let ids = elId.split(" ");
          console.log("Before");
          console.log(unsavedChanges);
          let tempClone = Object.assign({}, unsavedChanges);
          tempClone[current_image_id]["people"].splice(parseInt(ids[0]),1)[0];
          unsavedChanges = Object.assign({}, tempClone);
          console.log("After");
          console.log(unsavedChanges);
          for(let i = 0; i < selectedPoseElements.length; i++){
            selectedPoseElements[i].remove();
          }

          let svg = document.getElementById("svg");
          for(let i = 0; i < svg.childNodes.length; i++){
            let tempElId= svg.childNodes[i].getAttributeNS(null, "id");
            let tempIds = tempElId.split(" ");
            let tempPoseId = parseInt(tempIds[0]);
            console.log(tempPoseId);
            if(tempPoseId > parseInt(ids[0])){
              let newPoseId = tempPoseId -1;
              let newId = newPoseId.toString() + " " + tempIds[1];
              console.log(newId);
              svg.childNodes[i].setAttributeNS(null, "id", newId);
            }
          }

          document.getElementById("poseDelButton").disabled = true;
        }
      }
    </script>
  </body>
</html>
