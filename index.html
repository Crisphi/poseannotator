<!DOCTYPE html>
<html>
  <head>
    <title>Pose Annotator</title>
    <meta charset="UTF-8">
    <meta name="author" content="Cristian Ortega Singer">
    <script src="https://code.jquery.com/jquery-latest.js"></script>
    <!--import filsaver.js -->
    <script async="" src="https://cdn.rawgit.com/eligrey/FileSaver.js/5ed507ef8aa53d8ecfea96d96bc7214cd2476fd2/FileSaver.min.js"> </script>
    <!-- import jszip.js for zipping-->
    <script type="text/javascript" src="https://stuk.github.io/jszip/dist/jszip.min.js"></script>
    <style>
      /**div {border-style: dotted;}**/
      /**body {display: grid;}
      #header{
        grid-column: 1/span 3;
        grid-row: 1/ span 2;
      }
      #sidebar{
        grid-column: 1;
        grid-row: 2/span 7;
      }
      #workspace{
        grid-column: 2/span 3;
        grid-row: 2/span 5;
        grid-template-columns: max-content;
      }

      #footer{
        grid-column: 1/span 3;
        grid-row: 7;
      }

      .gridItem{display:grid;}**/

      #img-svg-wrap{
        position: relative;
        display: inline-block;
      }

      #image{
        min-width: 100%;
        height: auto;
      }

      #svg{
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        min-width: 100%;
        height: 100%;
      }

      line{
        fill:none;
        stroke-width:3;
        stroke: black;
      }
      .black{
        stroke:black;
      }
      .orange{
        stroke:orange;
      }

      .point{
        stroke: black;
      }

      #createDescr, #poseDelButton{
        display:none;
      }

      #filescroll{
        width: 200px;
        height: 300px;
        overflow: scroll;
      }

      li{
        list-style-type: none;
      }

      ul{
        padding-left: 0;
      }
    </style>
  </head>
  <body>
    <div class="container-fluid">
      <h1 class="display-5">Pose Annotator</h1>
      <nav class="navbar navbar-expand-sm bg-dark navbar-dark" id="navbar" class="row">
        <span class="navbar-brand">Logo</span>
        <ul class="navbar-nav">
          <li class="nav-item dropdown">
            <a class="nav-link dropdown-toggle" href="#" id="navbardrop" data-toggle="dropdown">
              Import
            </a>
            <div class="dropdown-menu">
              <h5 class="dropdown-header">Metadata:</h5>
              <input class="dropdown-item" type="file" id="metadata" accept="application/json" multiple>
              <h5 class="dropdown-header">Images:</h5>
              <input class="dropdown-item" type="file" id="images" accept="image/*" multiple>
              <a class="dropdown-item" id="importButton" href="javascript: handleFiles();"> Import Files</a>
            </div>
          </li>
          <li class="nav-item dropdown">
            <a class="nav-link dropdown-toggle" href="#" id="navbardrop" data-toggle="dropdown">
              Load
            </a>
            <div class="dropdown-menu">
              <input class="dropdown-item" type="file" id="workingfile" accept="application/json">
              <a class="dropdown-item" id="loadButton" href="javascript: handleWorkingFile();"> Load Project</a>
            </div>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="javascript: exportUnfinished();">Save</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="javascript: exportFinished();">Export</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="#">Settings</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="#">?</a>
          </li>
        </ul>
      </nav>
      <div id="main" class="row">
        <div id="sidebar" class="col-md-3 col-lg-3">
          <div class="row">
            <div class="col">
              <p> Checked: <span id = "checked">No</span></p>
            </div>
          </div>
          <div id="tools" class="row">
            <div class="col btn-group-vertical">
              <button type="button" class="btn btn-dark my-1" id="undoButton" onclick="resetPage();">Undo All Changes</button>
              <button type="button" class="btn btn-dark my-1" id="resetButton" onclick="toggleResetMode(!resetMode);">Reset Mode</button>
              <button type="button" class="btn btn-dark my-1" id="createButton" onclick="toggleCreationMode(!creationMode);">Creation Mode</button>
              <button type="button" class="btn btn-dark my-1" id="deleteButton" onclick="toggleDeletionMode(!deletionMode);">Deletion Mode</button>
              <button type="button" class="btn btn-dark my-1" id="selectButton" onclick="toggleSelectionMode(!selectionMode);">Selection Mode</button>
              <div class="btn-group">
                <button type="button" class="btn btn-dark my-1" id="lastPic" onclick="previousImage();">Prev</button>
                <button type="button" class="btn btn-dark my-1" id="nextPic" onclick="nextImage();">Next</button>
              </div>
            </div>
            <div class="col">
              <div id="optionsContainer" class="row">
                <div id="createDescr" class="row">
                  <div class="row">
                    <div class="col">
                      <button type="button" class="btn btn-dark my-1" id="createPoseButton" onclick="initWholePoseCreation();">Add new pose</button>
                    </div>
                  </div>
                  <div class="col">
                    <span> Possible Points to add </br>(klick on joint where a part of the pose is missing):</span> </br>
                  </div>
                  <div class="row">
                    <div class="col">
                      <svg id="xsvg" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="225 140 180 503.5" width="150px" onload="draggable(evt);">
                        <line x1="304.844" y1="158.085" x2="286.6189880371094" y2="146.37899780273438" class="xl black" id="xhead1" ></line>
                        <line x1="304.844" y1="158.085" x2="321.30999755859375" y2="146.09800720214844" class="xl" id="xhead2"></line>
                        <line x1="286.6189880371094" y1="146.37899780273438" x2="272.69500732421875" y2="164.41000366210938" class="xl black" id="xhead3"></line>
                        <line x1="321.30999755859375" y1="146.09800720214844" x2="337.718994140625" y2="160.0659942626953" class="xl black" id="xhead4"></line>
                        <line x1="304.844" y1="158.085" x2="309.149" y2="217.125" class="xl black" id="xspine1"></line>
                        <line x1="309.149" y1="217.125" x2="311.356" y2="377.002" class="xl black" id="xspine2"></line>
                        <line x1="309.149" y1="217.125" x2="265.398" y2="214.965" class="xl black" id="xarmL1"></line>
                        <line x1="265.398" y1="214.965" x2="241.82000732421875" y2="296.8479919433594" class="xl black" id="xarmL2"></line>
                        <line x1="241.82000732421875" y1="296.8479919433594" x2="234.33299255371094" y2="372.14501953125" class="xl black" id="xarmL3"></line>
                        <line x1="309.149" y1="217.125" x2="357.325" y2="217.193" class="xl black" id="xarmR1"></line>
                        <line x1="357.325" y1="217.193" x2="379.21" y2="302.628" class="xl black" id="xarmR2"></line>
                        <line x1="379.21" y1="302.628" x2="382.9330139160156" y2="369.89801025390625" class="xl black" id="xarmR3"></line>
                        <line x1="311.356" y1="377.002" x2="278.532" y2="377.052" class="xl black" id="xlegL1"></line>
                        <line x1="278.532" y1="377.052" x2="280.661" y2="501.84" class="xl black" id="xlegL2"></line>
                        <line x1="280.661" y1="501.84" x2="285.015" y2="620.016" class="xl black" id="xlegL3"></line>
                        <line x1="311.356" y1="377.002" x2="344.174" y2="374.887" class="xl black" id="xlegR1"></line>
                        <line x1="344.174" y1="374.887" x2="344.244" y2="497.407" class="xl black" id="xlegR2"></line>
                        <line x1="344.244" y1="497.407" x2="342.0530090332031" y2="614.6240234375" class="xl black" id="xlegR3"></line>
                        <line x1="285.015" y1="620.016" x2="267.1669921875" y2="630.7310180664062" class="xl black" id="xfootL1"></line>
                        <line x1="267.1669921875" y1="630.7310180664062" x2="244.47198486328125" y2="619.89501953125" class="xl black" id="xfootL2"></line>
                        <line x1="285.015" y1="620.016" x2="303.4849853515625" y2="636.5659790039062" class="xl black" id="xfootL3"></line>
                        <line x1="342.0530090332031" y1="614.6240234375" x2="368.5419921875" y2="627.5029907226562" class="xl black" id="xfootR1"></line>
                        <line x1="368.5419921875" y1="627.5029907226562" x2="393.6449890136719" y2="618.614013671875" class="xl black" id="xfootR2"></line>
                        <line x1="342.0530090332031" y1="614.6240234375" x2="324.5820007324219" y2="628.4340209960938" class="xl black" id="xfootR3"></line>
                        <circle cx="304.844" cy="158.085" r="5" class="xp black" id="x0"></circle>
                        <circle cx="309.149" cy="217.125" r="5" class="xp black" id="x1"></circle>
                        <circle cx="265.398" cy="214.965" r="5" class="xp black" id="x2"></circle>
                        <circle cx="241.82000732421875" cy="296.8479919433594" r="5" class="xp black" id="x3"></circle>
                        <circle cx="234.33299255371094" cy="372.14501953125" r="5" class="xp black" id="x4"></circle>
                        <circle cx="357.325" cy="217.193" r="5" class="xp black" id="x5"></circle>
                        <circle cx="379.21" cy="302.628" r="5" class="xp black" id="x6"></circle>
                        <circle cx="382.9330139160156" cy="369.89801025390625" r="5" class="xp black" id="x7"></circle>
                        <circle cx="311.356" cy="377.002" r="5" class="xp black" id="x8"></circle>
                        <circle cx="278.532" cy="377.052" r="5" class="xp black" id="x9"></circle>
                        <circle cx="280.661" cy="501.84" r="5" class="xp black" id="x10"></circle>
                        <circle cx="285.015" cy="620.016" r="5" class="xp black" id="x11"></circle>
                        <circle cx="344.174" cy="374.887" r="5" class="xp black" id="x12"></circle>
                        <circle cx="344.244" cy="497.407" r="5" class="xp black" id="x13"></circle>
                        <circle cx="342.0530090332031" cy="614.6240234375" r="5" class="xp black" id="x14"></circle>
                        <circle cx="286.6189880371094" cy="146.37899780273438" r="5" class="xp black" id="x15"></circle>
                        <circle cx="321.30999755859375" cy="146.09800720214844" r="5" class="xp black" id="x16"></circle>
                        <circle cx="272.69500732421875" cy="164.41000366210938" r="5" class="xp black" id="x17"></circle>
                        <circle cx="337.718994140625" cy="160.0659942626953" r="5" class="xp black" id="x18"></circle>
                        <circle cx="368.5419921875" cy="627.5029907226562" r="5" class="xp black" id="x19"></circle>
                        <circle cx="393.6449890136719" cy="618.614013671875" r="5" class="xp black" id="x20"></circle>
                        <circle cx="324.5820007324219" cy="628.4340209960938" r="5" class="xp black" id="x21"></circle>
                        <circle cx="267.1669921875" cy="630.7310180664062" r="5" class="xp black" id="x22"></circle>
                        <circle cx="244.47198486328125" cy="619.89501953125" r="5" class="xp black" id="x23"></circle>
                        <circle cx="303.4849853515625" cy="636.5659790039062" r="5" class="xp black" id="x24"></circle>
                      </svg>
                    </div>
                  </div>
                </div>
                <div id="poseDelDescr" class="row">
                    <div class="col">
                      <button type="button" class="btn btn-dark my-1" id="poseDelButton" onclick="deletePose();" disabled = true>Delete Pose</button>
                    </div>
                  </div>
              </div>
            </div>
          </div>
          <div id="files" class="row">
            <div class="col">
              <p>Images:</p>
              <div id="filescroll">
                <ul id="fileview"></ul>
              </div>
            </div>
          </div>
        </div>
        <div id="workspace" class="col">
          <div id="img-svg-wrap">
            <img x= 0 y= 0 id="image" href="" alt="current Picture">
            <svg id="svg" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" onload="draggable(evt)">
            </svg>
          </div>
        </div>
      </div>
      <div id="footer" class="gridItem">
        Footer
      </div>
    </div>
    <script type="text/javascript">
    "use strict";

    //initializing variables
      var IMG_FILEPATH = "img/";
      var META_FILEPATH = "metadata/";
      var single_meta_file = false;
      var working_file = false;
      var meta_file_list = {};
      var annotations;
      var image_file_list = {};
      var current_image_id;
      var current_image_source;
      var meta_id;
      var unsavedChanges = {};

      var fileview;

      var working_file_list = {};
      var working_data = {};

      var selectedPoseElements = [];

      var color = "black";
      var resetMode = false;
      var creationMode = false;
      var wholePoseCreationMode = false;
      var deletionMode = false;
      var selectionMode = false;
      var creating = false;
      var creatingWhole = false;

      var bodyparts = {};

      var bodyschema = {
        "head1" : [0, 15],
        "head2" : [0, 16],
        "head3" : [15, 17],
        "head4" : [16, 18],
        "spine1": [0, 1],
        "spine2": [1, 8],
        "armL1" : [1, 2],
        "armL2" : [2, 3],
        "armL3" : [3, 4],
        "armR1" : [1, 5],
        "armR2" : [5, 6],
        "armR3" : [6, 7],
        "legL1" : [8, 9],
        "legL2" : [9, 10],
        "legL3" : [10, 11],
        "legR1" : [8, 12],
        "legR2" : [12, 13],
        "legR3" : [13, 14],
        "footL1": [11, 22],
        "footL2": [22, 23],
        "footL3": [11, 24],
        "footR1": [14, 19],
        "footR2": [19, 20],
        "footR3": [14, 21]
      };

      var highlighted;
      var highlightedModel = [];
      var greenHighlighted;
      var creationId;
      var creationId2;
      var creationCoordX;
      var creationCoordY;
      var creationPoseId;
      var selectedElement;
      var offset;
      var transform;
      var bbox;
      var minX;
      var minY;
      var maxX;
      var maxY;
      var boundaryX1 = 0;
      var boundaryY1 = 0;
      var boundaryX2 = document.getElementById("svg").width;
      var boundaryY2 = document.getElementById("svg").height;
      var svgNS = "http://www.w3.org/2000/svg";


      // Check for the various File API support.
      if (!window.File || !window.FileReader || !window.FileList || !window.Blob) {
        alert("The File APIs are not fully supported in this browser.");
      }

      //various event listeners for tracking key and mouse navigation
      document.addEventListener("keydown", function(event) {
        if(event.keyCode == 37) {
          console.log("Left was pressed");
          previousImage();
        }
        else if(event.keyCode == 39) {
          console.log("Right was pressed");
          nextImage();
        }
        else if(event.keyCode == 40) {
          console.log("Down was pressed");
          changeAnnoColor();
        }
        else if(event.keyCode == 68){
          console.log("d was pressed");
          toggleDeletionMode(!deletionMode);
        }else if(event.keyCode == 67){
          console.log("c was pressed");
          toggleCreationMode(!creationMode);
        }else if(event.keyCode == 82){
          console.log("r was pressed");
          toggleResetMode(!resetMode);
        }else if(event.keyCode == 83){
          console.log("s was pressed");
          toggleSelectionMode(!selectionMode);
        }
      });

      //function for making the annotation points draggable
      function draggable(evt){
        var svg = evt.target;

        //set event listeners for mouse movement
        svg.addEventListener("mousedown", function(event){
          if(creating){
            createPosePart(event);
            creating = false;
          }else if(resetMode){
            undoChanges(event);
          }else if(creationMode){
            selectAddingPoint(event);
            addAnnotation(event);
          }else if(deletionMode){
            deletePoint(event);
          }else if(selectionMode){
            selectPose(event);
          }else{
            startDrag(event);
          }
        });
        svg.addEventListener("mousedown", startDrag);
        svg.addEventListener("mousemove", drag);
        svg.addEventListener("mouseup", endDrag);
        svg.addEventListener("mouseleave", endDrag);

        //function for adding new points to an uncomplete bodyschema
        function addAnnotation(evt){
          //get svg and posemodel
          let descr = document.getElementById("createDescr");
          let svg = document.getElementById("svg");
          let children = svg.childNodes;
          if(evt.target.classList.contains("point")){
            //reset possible highlights
            if(highlighted){
              highlighted.removeAttribute("style");
              deleteDescr();
            }
            selectedElement = evt.target;
            highlighted = selectedElement;
            //highlight selected point and save his id & coordinates for point and line creation
            selectedElement.setAttributeNS(null, "style", "fill: red;")
            let pointId = selectedElement.getAttribute("id");
            let ids = pointId.split(" ");
            creationId2 = ids[1];
            creationPoseId = ids[0];
            creationCoordX = selectedElement.getAttributeNS(null, "cx");
            creationCoordY = selectedElement.getAttributeNS(null, "cy");

            //get points that are connected with selected point via bodyschema
            for(let i in bodyschema){
              if(bodyschema[i][0] == creationId2){
                for(let j = 0; j < children.length; j++){
                  if(children[j].classList.contains("point")){
                    let pointId2 = children[j].getAttribute("id");
                    let ids2 = pointId2.split(" ");
                    if((ids2[1] == bodyschema[i][1]) && (ids2[0] == ids[0])){
                      let xTemp = parseInt(children[j].getAttribute("cx"));
                      let yTemp = parseInt(children[j].getAttribute("cy"));
                      //if the point doesn't exist, save it in array and highlight equivalent in pose model
                      if((xTemp == "0") && (yTemp == "0")){
                        let tempidp = "x" + ids2[1].toString();
                        let tempxp = document.getElementById(tempidp);
                        tempxp.setAttributeNS(null, "style", "fill:red;");
                        let tempid = "x" + i.toString();
                        let tempx = document.getElementById(tempid);
                        tempx.setAttributeNS(null, "style", "stroke: red;");
                        highlightedModel.push(tempxp, tempx);
                      }
                    }
                  }
                }
              }
            }
          }
        }

        //funcion that handles interaction with the pose model in creation mode
        function selectAddingPoint(evt){
          //check if event occured in pose model svg
          if((evt.target.classList.contains("xp")) && (highlightedModel.includes(evt.target))){
            //handles the reset of highlighting
            if((greenHighlighted) && highlightedModel.includes(greenHighlighted)){
              greenHighlighted.setAttributeNS(null, "style", "fill: red;");
            }else if(greenHighlighted){
              greenHighlighted.setAttributeNS(null, "style", "fill: black;");
              greenHighlighted = null;
            }
            selectedElement = evt.target;
            //highlights selected Point in pose model
            selectedElement.setAttributeNS(null, "style", "fill: green;");
            greenHighlighted = selectedElement;
            //get and save id of selected point to create equivalent in the real image
            let idRaw = selectedElement.getAttributeNS(null, "id");
            let id = idRaw.split("x")[1];
            console.log(id);
            creationId = id;
            creating = true;
          }
        }
        //handles actual creation of new pose parts in the current image
        function createPosePart(evt){
          if(evt.target.getAttributeNS(null, "id") == "svg"){
            console.log(evt.target);
            //get coordinates for point to create
            let coord = getMousePos(evt);
            let x2 = coord.x;
            let y2 = coord.y;
            let idp = creationPoseId + " " + creationId;

            console.log(idp);

            //overwrite coordinates of missing point to make it visible
            console.log(x2, y2);
            let cPoint = document.getElementById(idp);
            cPoint.setAttributeNS(null, "cx", x2);
            cPoint.setAttributeNS(null, "cy", y2);

            //create line
            let idl;
            let tempEl;
            for(let i in bodyschema){
              if((bodyschema[i][0] == creationId)&&(bodyschema[i][1] == creationId2)){
                idl = creationPoseId + " " + i;
                console.log(idl);
                createLine(x2, y2, creationCoordX, creationCoordY, idl);
              }else if((bodyschema[i][1] == creationId)&&(bodyschema[i][0] == creationId2)){
                idl = creationPoseId + " " + i;
                console.log(idl);
                createLine(creationCoordX, creationCoordY, x2, y2, idl);
              }
              tempEl = i;
            }
            if(creatingWhole){
              for(let i = 0; i < highlightedModel.length; i++){
                highlightedModel[i].setAttributeNS(null, "style", "fill: black;");
              }
              highlightedModel = [];
              creatingWhole = false;
            }

          }
        }

        //set coordinates of selected point back to default
        function undoChanges(evt){
          if(evt.target.classList.contains("point")){
            selectedElement = evt.target;
            if(selectedElement.hasAttributeNS(null,"transform")){
              selectedElement.removeAttributeNS(null, "transform");

              let lineIds = getLineIds();

              let x = selectedElement.getAttributeNS(null, "cx");
              let y = selectedElement.getAttributeNS(null, "cy");
              for(let k in lineIds){
                //console.log(k);
                let line = document.getElementById(k.toString());

                if(line){
                  if(lineIds[k] == 0){
                    line.setAttributeNS(null,"x1", x);
                    line.setAttributeNS(null,"y1", y);
                    //console.log("changed x1 and y1");
                  }else if(lineIds[k] == 1){
                    line.setAttributeNS(null,"x2", x);
                    line.setAttributeNS(null,"y2", y);
                    //console.log("changed x2 and y2");
                  }else{
                    console.log("An error occured. Look in source code function undoChanges() to see what happened.");
                  }
                }
              }
            }
          }
        }

        //Delete parts of the pose
        function deletePoint(evt){
          console.log("Point Deletion");

          if(evt.target.classList.contains("point")){
            selectedElement = evt.target;
            //removes transformations if they exist
            if(selectedElement.hasAttributeNS(null,"transform")){
              selectedElement.removeAttributeNS(null, "transform");
              //sets coordinates of point to 0
              selectedElement.setAttributeNS(null, "cx", 0);
              selectedElement.setAttributeNS(null, "cy", 0);

              //get all lines that connect to point
              let lineIds = getLineIds();
              //delete all connected lines
              for(let k in lineIds){
                //console.log(k);
                let line = document.getElementById(k.toString());
                if(line){
                  line.remove();
                }
              }
            }
          }
        }
        //select whole pose and not just one point
        function selectPose(evt){
          console.log("Select Pose Start");
          selectedPoseElements = [];
          if(evt.target.classList.contains("point")){
            selectedElement = evt.target;

            //get pose id of clicked point
            let pointId = selectedElement.getAttribute("id");
            let ids = pointId.split(" ");
            let pointschemaId = ids[1];
            let poseId = ids[0];

            let svg = document.getElementById("svg");

            //get all svg elements with the same pose id and save them in selectedPoseElements array
            for(let i = 0; i < svg.children.length; i++){
              let tempElementId = svg.children[i].getAttribute("id");
              let idsTemp = tempElementId.split(" ");
              if(poseId == idsTemp[0]){
                selectedPoseElements.push(svg.children[i]);
                svg.children[i].setAttributeNS(null, "style", "stroke: blue;");
              }else{
                svg.children[i].removeAttributeNS(null, "style");
              }
            }

            //enable delete button if user selected a pose (clicked on a point on svg)
            if(selectedPoseElements){
                console.log(selectedPoseElements);
                let btn = document.getElementById("poseDelButton");
                btn.disabled = false;
            }else{
              console.log("An Error occured. Please look at function selectPose(evt) in code.");
            }
          }
        }

        //track mouseposition on screen if mouse interacts with svg
        function getMousePos(evt){
          let ctm = svg.getScreenCTM();
          if(evt.touches){
            evt = evt.touches[0];
          }
          return{
            x: (evt.clientX - ctm.e) / ctm.a,
            y: (evt.clientY - ctm.f) / ctm.d
          };
        }

        // handles mousedown event, starts dragging process
        function startDrag(evt){
          let svgtemp = document.getElementById("svg");

          //set boundaries to Imagesize so that it is impossible to drag points out of view
          boundaryX2 = svgtemp.width.baseVal.value;
          boundaryY2 = svgtemp.height.baseVal.value;

          //console.log("Boundaries:");
          //console.log(boundaryX2);
          //console.log(boundaryY2);

          //correct mouse offset in relation to svg through a transformation
          if(evt.target.classList.contains("point")){
            selectedElement = evt.target;
            offset = getMousePos(evt);
            //console.log(offset);

            let transforms = selectedElement.transform.baseVal;

            if(transforms.length === 0 || transforms.getItem(0).type !== SVGTransform.SVG_TRANSFORM_TRANSLATE){
              let translate = svg.createSVGTransform();
              translate.setTranslate(0,0);
              selectedElement.transform.baseVal.insertItemBefore(translate,0);
            }

            transform = transforms.getItem(0);
            offset.x -= transform.matrix.e;
            offset.y -= transform.matrix.f;

            //console.log(offset.x);
            //console.log(offset.y);

            //set boundaries according to the collision box of svg element
            bbox = selectedElement.getBBox();
            minX = boundaryX1 - bbox.x;
            maxX = boundaryX2 -bbox.x - bbox.width;
            minY = boundaryY1 - bbox.y;
            maxY = boundaryY2 - bbox.y - bbox.height;
          }
        }

        //handles mousemove event; the dragging process itself
        function drag(evt){
          if(selectedElement){
            evt.preventDefault();
            let coord = getMousePos(evt);
            let dx = coord.x - offset.x;
            let dy = coord.y - offset.y;

            //make shure svg element stays within boundaries
            if(dx < minX){
              dx = minX;
            }else if(dx >maxX){
              dx = maxX;
            }

            if(dy < minY){
              dy = minY;
            }else if(dy > maxY){
              dy = maxY;
            }
            //set new position for svg point
            transform.setTranslate(dx, dy);
            let lineIds = getLineIds();

            for(let k in lineIds){
              //console.log(k);
              let line = document.getElementById(k.toString());

              if(line){
                if(lineIds[k] == 0){
                  line.setAttributeNS(null,"x1", coord.x);
                  line.setAttributeNS(null,"y1", coord.y);
                  //console.log("changed x1 and y1");
                }else if(lineIds[k] == 1){
                  line.setAttributeNS(null,"x2", coord.x);
                  line.setAttributeNS(null,"y2", coord.y);
                  //console.log("changed x2 and y2");
                }else{
                  console.log("An error occured. Look in source code function pointchange() to see what happened.");
                }
              }
            }
          }
        }

        //set new position for svg lines if selected point is one of the coordinates
        function getLineIds(){
          //get point id and bodyschema ids for identifing correct lines
          let pointId = selectedElement.getAttribute("id");
          let ids = pointId.split(" ");
          let pointschemaId = ids[1];
          let poseId = ids[0];
          //console.log("Pointschema Id: " + pointschemaId);
          let lineIds = {};
          //get all bodyparts that have the right identifier
          for(let i in bodyschema){
            for(let j = 0; j < bodyschema[i].length; j++){
              if(bodyschema[i][j] == pointschemaId){
                lineIds[poseId + " " + i] = j;
              }
            }
          }
          return lineIds;
        }

        //handles mouseup and mouseleave events; stops dragging process
        function endDrag (evt){
          selectedElement = false;
        }
      }

      //prepare metadata for new Pose in image
      function initWholePoseCreation(){
        cacheAnnotations();
        let facePoints = [];
        for(let i= 0; i < 210; i++){
          facePoints.push(0);
        }
        let handLeftPoints = [];
        for(let i= 0; i < 63; i++){
          handLeftPoints.push(0);
        }
        let handRightPoints = [];
        for(let i= 0; i < 63; i++){
          handRightPoints.push(0);
        }
        let posePoints = [];
        for(let i= 0; i < 75; i++){
          posePoints.push(0);
        }
        let dataInit = {
          face_keypoints_2d: facePoints,
          face_keypoints_3d: [],
          hand_left_keypoints_2d: handLeftPoints,
          hand_left_keypoints_3d: [],
          hand_right_keypoints_2d: handRightPoints,
          hand_right_keypoints_3d: [],
          pose_keypoints_2d: posePoints,
          pose_keypoints_3d: []
        }
        unsavedChanges[current_image_id]["people"].push(dataInit);

        console.log(unsavedChanges[current_image_id]["people"]);

        creationPoseId = unsavedChanges[current_image_id]["people"].length - 1;

        let xsvg = document.getElementById("xsvg");
        for(let i = 0; i < xsvg.childNodes.length; i++){
          if((xsvg.childNodes[i].classList)&&(xsvg.childNodes[i].classList.contains("xp"))){
            xsvg.childNodes[i].setAttributeNS(null, "style", "fill: red;");
            highlightedModel.push(xsvg.childNodes[i]);
          }
        }
        creatingWhole = true;
        loadAnnotations();
      }

      //Not finished will be included in future versions: load json file if the annotations are saved in only one json file
      function loadMetaFileSingle(){

      }

      //load current json file if the annotations are saved in multiple json files
      function loadMetaFiles(){
        single_meta_file = false;

        //console.log(meta_file_list);

        //get name of json file through the name of the image file
        let id = current_image_source.split(".")[0];
        //create a new regex pattern
        let patt = new RegExp(id + "_");

        //console.log(id);
        //search in loaded meta files for the correct file via file name and save file in meta_id
        for(let i = 0; i < meta_file_list.length; i++){
          let d = meta_file_list[i];
          if(patt.test(d.name)){
            //console.log(d);
            meta_id = d;
          }
        }

        //if file found launch a file reader to get content of file as a string array
        if(meta_id){
          let reader = new FileReader();
          reader.onload = getAnnotations;
          //console.log(meta_id);
          reader.readAsText(meta_id);
        }

        function getAnnotations(t, callback = function(){loadAnnotations();}){
          //console.log(callback);
          let lines = t.target.result;
          let a = JSON.parse(lines);
          annotations = $.extend(annotations,a);
          //console.log("Annotations:");
          //console.log(annotations);
          callback();
        }
      }

      //initiate the file reading process of json and image files
      function handleFiles(){
        workingfile = false;
        //get json and image files from the file selector
        image_file_list = document.getElementById("images").files;
        meta_file_list = document.getElementById("metadata").files;

        displayFileList();
        //catching errors
        if(!image_file_list[0]){
          alert("You have to select image files before you can continue!");
        }else if(!meta_file_list[0]){
          alert("You have to select JSON files before you can continue!");
        }else if(image_file_list[0] && meta_file_list[0]){
          console.log(image_file_list);
          console.log(meta_file_list);
          if(annotations){
            if(confirm("Annotations already included! Unsaved changes will be lost! Do you want to replace annotation File(s)?")){
              current_image_id = 0;
              loadImage();
              annotations = {};
              unsavedChanges = {};
              if(meta_file_list.length > 1){
                loadMetaFiles();
              }else{
                loadMetaFileSingle();
              }
            }
          }else{
            current_image_id = 0;
            loadImage();
            annotations = {};
            unsavedChanges = {};
            //check if there are multiple json files or just one
            if(meta_file_list.length > 1){
              loadMetaFiles();
            }else{
              loadMetaFileSingle();
            }
          }
        }
      }

      //display image
      function loadImage(){
        destroySvgEl();
        let currentFileLink = document.getElementById(String(current_image_id) + "_link");
        currentFileLink.style.color = "red";

        if(!image_file_list[current_image_id]){
          //console.log(current_image_id);
          alert("An Error occured! No Image Id found.")
        }else{
          let imag = document.getElementById("image");
          current_image_source = image_file_list[current_image_id].name;

          if(imag.complete){
            let new_image = new Image();
            new_image.id = "image";
            new_image.src = IMG_FILEPATH + current_image_source;
            imag.parentNode.insertBefore(new_image, imag);
            imag.parentNode.removeChild(imag);
          }
        }
      }

      function handleWorkingFile(){
        workingfile = true;
        single_meta_file = false;
        working_file_list = document.getElementById("workingfile").files;
        if(!working_file_list[0]){
          alert("You have to select a project to load before you can continue!");
        }else{
          console.log(working_file_list);
          if(annotations){
            if(confirm("Annotations already included! Unsaved changes will be lost! Do you want to replace annotation File(s)?")){
              readWorkingFile();
            }
          }else{
            readWorkingFile();
          }
        }

        function readWorkingFile(){
          current_image_id = 0;
          annotations = {};
          unsavedChanges = {};

          let reader = new FileReader();
          reader.onload = getAnnotations;
          console.log(working_file_list[0]);
          reader.readAsText(working_file_list[0]);
          console.log(reader.readyState);

          function getAnnotations(t, callback = function(){
              console.log("Working Data:");
              console.log(working_data);
              let imageListTemp = [];
              let metaListTemp = [];
              for(let i in working_data){
                imageListTemp[i] = {"name" : working_data[i].image_source};
                metaListTemp[i] = {"name" : working_data[i].meta_source};
              }
              image_file_list = imageListTemp.slice();
              meta_file_list = metaListTemp.slice();
              /**image_file_list = Object.assign({}, imageListTemp);
              meta_file_list = Object.assign({}, metaListTemp);**/
              console.log(image_file_list);
              console.log(meta_file_list);

              displayFileList();
              loadImage();
              loadWorkingMeta();
            }){
            //console.log(callback);
            let lines = t.target.result;
            let a = JSON.parse(lines);
            working_data = $.extend(working_data,a);
            callback();
          }
        }
      }

      function loadWorkingMeta(){
        let checkObject = document.getElementById("checked");

        for(let i in working_data){
          if(current_image_source == working_data[i].image_source){
            annotations["people"] = Object.values(working_data[i].people);
            if(working_data[i].checked == true){
              checkObject.innerHTML = "Yes";
            }else{
              checkObject.innerHTML = "No";
            }
            console.log("Annotations:");
            console.log(annotations);
            loadAnnotations();
          }
        }
      }

      //disables all modes (optional leave current mode on)
      function disableModes(current = ""){
        if(current == "resetMode"){
          if(creationMode){
            toggleCreationMode(false);
          }
          if(selectionMode){
            toggleSelectionMode(false);
          }
          deletionMode = false;
        }else if(current == "deletionMode"){
          if(creationMode){
            toggleCreationMode(false);
          }
          if(selectionMode){
            toggleSelectionMode(false);
          }
          resetMode = false;
        }else if(current == "creationMode"){
          resetMode = false;
          deletionMode = false;
          if(selectionMode){
            toggleSelectionMode(false);
          }
        }else if(current == "selectionMode"){
          if(creationMode){
            toggleCreationMode(false);
          }
          resetMode = false;
          deletionMode = false;
        }else{
          if(creationMode){
            toggleCreationMode(false);
          }
          if(selectionMode){
            toggleSelectionMode(false);
          }
          resetMode = false;
          deletionMode = false;
          let currentFileLink = document.getElementById(String(current_image_id) + "_link");
          currentFileLink.style.color = "";
        }
      }

      //function for loading next image with annotations
      function nextImage(){
        disableModes();
        //deleteDescr();
        cacheAnnotations();
        if(current_image_id >= image_file_list.length -1){
          current_image_id = 0;
        }else{
          current_image_id++;
        }
        loadImage();
        if(workingfile){
          loadWorkingMeta();
        }else if(single_meta_file){
          loadMetaFileSingle();
        }else{
          loadMetaFiles();
        }
      }

      //function for loading previous image with annotations
      function previousImage(){
        disableModes();
        //deleteDescr();
        cacheAnnotations();
        if(current_image_id <= 0){
          current_image_id = image_file_list.length - 1;
          console.log("Current: " + current_image_id);
          console.log("length: " + image_file_list.length);
        }else{
          current_image_id--;
          console.log("Current: " + current_image_id);
          console.log("length: " + image_file_list.length -1);
        }
        loadImage();
        if(workingfile){
          loadWorkingMeta();
        }else if(single_meta_file){
          loadMetaFileSingle();
        }else{
          loadMetaFiles();
        }
      }

      function specificImage(id){
        disableModes();
        //deleteDescr();
        cacheAnnotations();
        if((id < image_file_list.length) && (id >= 0)){
          current_image_id = id;
        }else{
          alert("An Error occured! Look in code function 'specificImage(id)'");
        }
        loadImage();
        if(workingfile){
          loadWorkingMeta();
        }else if(single_meta_file){
          loadMetaFileSingle();
        }else{
          loadMetaFiles();
        }
      }
      //Not finished will be included in future versions: load annotations if there is only one json file
      function loadAnnotationsSingle(){

      }

      // load annotations if there are multiple json files
      function loadAnnotations(){
        let results = [];
        let p;
        let checkObject = document.getElementById("checked");
        if(current_image_id in unsavedChanges){
          p = unsavedChanges[current_image_id]["people"];
          checkObject.innerHTML = "Yes";
        }else{
          p = annotations["people"];
          if(!workingfile){
            checkObject.innerHTML = "No";
          }
        }
        //console.log(p);
        //save pose keypoints in results
        for(let i = 0; i < p.length; i++){
          let t = p[i]["pose_keypoints_2d"];
          //console.log(t);
          results.push(t);
        }
        console.log("Results:");
        console.log(results);
        //start disply for each pose
        for(let j= 0; j < results.length; j++){
          displayAnnotations(results[j], j);
        }
      }

      //prepare pose keypoints for display as svg
      function displayAnnotations(r, c){
        let counter = c;
        let points = [];

      //delete z letiable (keypoint schema x,y,z with z = confidence level)
        for(let i = 0; i < r.length; i++){
          if((i+1) % 3 != 0){
            points.push(r[i]);
          }
        }

        //console.log("Points:");
        //console.log(points);

        let newpoints = {};
        for(let i = 0; i < points.length; i += 2){
            let id = i/2;
            newpoints[id] = [points[i], points[i+1]];
        }
        //console.log(newpoints);

        //set point schema for display
        bodyparts = {
          head1 : [newpoints[0], newpoints[15]],
          head2 : [newpoints[0], newpoints[16]],
          head3 : [newpoints[15], newpoints[17]],
          head4 : [newpoints[16], newpoints[18]],
          spine1: [newpoints[0], newpoints[1]],
          spine2: [newpoints[1], newpoints[8]],
          armL1 : [newpoints[1], newpoints[2]],
          armL2 : [newpoints[2], newpoints[3]],
          armL3 : [newpoints[3], newpoints[4]],
          armR1 : [newpoints[1], newpoints[5]],
          armR2 : [newpoints[5], newpoints[6]],
          armR3 : [newpoints[6], newpoints[7]],
          legL1 : [newpoints[8], newpoints[9]],
          legL2 : [newpoints[9], newpoints[10]],
          legL3 : [newpoints[10], newpoints[11]],
          legR1 : [newpoints[8], newpoints[12]],
          legR2 : [newpoints[12], newpoints[13]],
          legR3 : [newpoints[13], newpoints[14]],
          footL1: [newpoints[11], newpoints[22]],
          footL2: [newpoints[22], newpoints[23]],
          footL3: [newpoints[11], newpoints[24]],
          footR1: [newpoints[14], newpoints[19]],
          footR2: [newpoints[19], newpoints[20]],
          footR3: [newpoints[14], newpoints[21]]
        }
        //delete all points that have 0 value (if 0 bodypart is not assigned)
        for(let i in bodyparts){
          //console.log("id: " + i);
          if((bodyparts[i][0][0] == 0) || (bodyparts[i][1][1] == 0)){
            delete bodyparts[i];
          }
        }
        //console.log(bodyparts);

        //stringify point arrays and start line creation
        let x1;
        let y1;
        let x2;
        let y2;
        for(let id in bodyparts){
          if((bodyparts[id][0])&& (bodyparts[id][1])){
            x1 = bodyparts[id][0][0].toString();
            y1 = bodyparts[id][0][1].toString();
            x2 = bodyparts[id][1][0].toString();
            y2 = bodyparts[id][1][1].toString();
          }
          let idtemp = counter.toString() + " " + id.toString();
          createLine(x1, y1, x2, y2, idtemp);
        }

        for(let id in newpoints){
          let x = newpoints[id][0];
          let y = newpoints[id][1];
          let strx = x.toString();
          let stry = y.toString();
          //console.log(strx + " " + stry);
          let idtemp = counter.toString() + " " + id.toString();
          createPoint(strx, stry, idtemp);
        }
      }

      //creates a new svg point (circle) and sets all the attributes to the correct values
      function createPoint(x, y, id, nextId = null){
        let point = document.createElementNS(svgNS, "circle");
        let classes = color + " point";
        point.setAttributeNS(null,"cx", x);
        point.setAttributeNS(null, "cy", y);
        point.setAttributeNS(null, "r", "5");
        point.setAttributeNS(null, "class", classes);
        point.setAttributeNS(null,"id", id.toString());
        document.getElementById("svg").appendChild(point);
      }

      //creates a new svg line and sets all the attributes to the correct values
      function createLine(x1, y1, x2, y2, id){
        let line = document.createElementNS(svgNS, "line");
        line.setAttributeNS(null, "x1", x1);
        line.setAttributeNS(null, "y1", y1);
        line.setAttributeNS(null, "x2", x2);
        line.setAttributeNS(null, "y2", y2);
        line.setAttributeNS(null, "class", color);
        line.setAttributeNS(null, "id", id);

        document.getElementById("svg").appendChild(line);
      }

      //destroy all displayed svg elements
      function destroySvgEl(){
        let svg = document.getElementById("svg");
        while (svg.firstChild) {
          svg.removeChild(svg.lastChild);
        }
      }

      //Not finished will be included in future versions: prepare pose keypoints for display as svg if only one json file is given
      function displayAnnotationsSingle(r){
      }

      //change css class of svg elements to change appearance for the current and following annotations
      function changeAnnoColor(){
        let svg = document.getElementById("svg");
        if(color == "black"){
          color = "orange"
        }else{
          color ="black"
        }
        for(let i = 0; i < svg.childNodes.length; i++){
          svg.childNodes[i].style.stroke = color;
        }
      }

      //function for chaching the made changes
      function cacheAnnotations(){
        let svg = document.getElementById("svg");
        let children = svg.childNodes;
        let pointcounter = 0;
        let x;
        let y;
        let cx;
        let cy;

        for(let i = 0; i < children.length; i++){
          if(children[i].classList.contains("point")){

            cx = children[i].getAttribute("cx");
            cy = children[i].getAttribute("cy");

            // flatten the transformations made to the svg points to get new coordinates
            if(children[i].transform.baseVal.length != 0){
              let matrix = children[i].transform.baseVal.consolidate().matrix;
              let cache = svg.createSVGPoint();
              cache.x = cx;
              cache.y = cy;
              cache = cache.matrixTransform(matrix);
              x = cache.x;
              y = cache.y;
            }else{
              x = cx;
              y = cy;
            }

            //get Ids to save coordinates in the given schema and at the right index
            let pointId = children[i].getAttribute("id");
            let ids = pointId.split(" ");
            let pointschemaId = ids[1];
            let poseId = ids[0];
            //console.log("Ids: " + "point: " + pointschemaId + " pose: "+ poseId);

            let intPose = parseInt(poseId);
            let intId = parseInt(pointschemaId);
            let id1 = (intId * 2) + pointcounter;
            let id2 = id1 + 1;

            if(intId == 24){
              pointcounter = 0;
            }else{
              pointcounter++;
            }
            //console.log(intId, id1, id2);
            unsavedChanges[current_image_id] = Object.assign({}, annotations);
            //overwrite old coordinates with new ones
            unsavedChanges[current_image_id]["people"][poseId]["pose_keypoints_2d"][id1] = x;
            unsavedChanges[current_image_id]["people"][poseId]["pose_keypoints_2d"][id2] = y;
            unsavedChanges[current_image_id]["image_source"] = image_file_list[current_image_id];
            unsavedChanges[current_image_id]["meta_source"] = meta_id;
          }
        }

        console.log("Unsaved changes: ", unsavedChanges);
      }

      //reset all poses to the values from the original json file
      function resetPage (){
        disableModes();
        //overwrite cached annotations with the ones from json file
        unsavedChanges[current_image_id] = Object.assign({},annotations);
        destroySvgEl();
        loadAnnotations();
      }

      //enables/disables creation mode and sets color of poses to a different value for recognition
      function toggleCreationMode(on){
        let descr = document.getElementById("createDescr");
        disableModes("creationMode");
        let svg = document.getElementById("svg");
        if(on){
          creationMode = true;
          descr.style.display = "block";
          for(let i = 0; i < svg.childNodes.length; i++){
            svg.childNodes[i].setAttributeNS(null, "style", "stroke: green;");
          }
        }else{
          creationMode = false;
          creating = false;

          if(highlighted){
            highlighted.removeAttribute("style");
            highlighted = null;
          }

          descr.style.display = "none";
          for(let i = 0; i < svg.childNodes.length; i++){
            svg.childNodes[i].removeAttributeNS(null, "style");
          }
          deleteDescr();
        }
      }

      //enables/disables reset mode and sets color of poses to a different value for recognition
      function toggleResetMode(on){
        disableModes("resetMode");
        let svg = document.getElementById("svg");
        if(on){
          resetMode = true;
          for(let i = 0; i < svg.childNodes.length; i++){
            svg.childNodes[i].setAttributeNS(null, "style", "stroke: purple;");
          }
        }else{
          resetMode = false;
          for(let i = 0; i < svg.childNodes.length; i++){
            svg.childNodes[i].removeAttributeNS(null, "style");
          }
        }
      }

      //enables/disables deletion mode and sets color of poses to a different value for recognition
      function toggleDeletionMode(on){
        disableModes("deletionMode");
        let svg = document.getElementById("svg");
        if(on){
          deletionMode = true;
          for(let i = 0; i < svg.childNodes.length; i++){
            svg.childNodes[i].setAttributeNS(null, "style", "stroke: red;");
          }
        }else{
          deletionMode = false;
          for(let i = 0; i < svg.childNodes.length; i++){
            svg.childNodes[i].removeAttributeNS(null, "style");
          }
        }
      }

      function toggleSelectionMode(on){
        disableModes("selectionMode");
        let svg = document.getElementById("svg");
        let delBtn = document.getElementById("poseDelButton");
        if(on){
          selectionMode = true;
          for(let i = 0; i < svg.childNodes.length; i++){
            svg.childNodes[i].setAttributeNS(null, "style", "stroke: blue;");
          }
          delBtn.style.display = "block";
          delBtn.disabled = true;
        }else{
          selectionMode = false;
          delBtn.disabled = true;
          delBtn.style.display = "none";
          for(let i = 0; i < svg.childNodes.length; i++){
            svg.childNodes[i].removeAttributeNS(null, "style");
          }
        }
      }

      //deletes additional buttons for distinct bodyparts in the tool area added creation mode
      function deleteDescr(){
        let descrsvg = document.getElementById("xsvg");
        for(let j = 0; j < descrsvg.childNodes.length; j++){
          if(descrsvg.childNodes[j].classList){
            descrsvg.childNodes[j].setAttributeNS(null, "style", "stroke: black;");
            descrsvg.childNodes[j].setAttributeNS(null, "style", "fill: black;");
          }
        }
        highlightedModel = [];

      }

      //function for creating and downloading a working file with already made changes
      async function exportUnfinished(){
        //save changes on current picture
        cacheAnnotations();

        let exportFile = [];
        let found = false;

        //checks if there are unsaved Changes
        if(unsavedChanges[0]){
          for(let i = 0; i < meta_file_list.length; i++){
            //checks if there are unsaved Changes in the current metadata-file
            for(let j in unsavedChanges){
              if(i == j){
                found = true;
                //save new metadata in the exportFile array
                exportFile[i] = Object.assign({}, unsavedChanges[j]);
                exportFile[i]["image_source"] = unsavedChanges[j]["image_source"].name;
                exportFile[i]["meta_source"] = unsavedChanges[j]["meta_source"].name;
                exportFile[i]["checked"] = true;
              }
            }
            //current image has no changes yet
            if(found == false){
              let meta_name = meta_file_list[i].name;
              let id = meta_name.split("_")[0];

              //search for the image that belongs to the metadata
              let patt = new RegExp(id + ".");
              let imageTemp;

              for(let k = 0; k < image_file_list.length; k++){
                let d = image_file_list[k];
                if(patt.test(d.name)){
                  console.log(d);
                  imageTemp = d;
                }
              }
              //wait for the results of the file reading process
              let result = await readFileAsync(meta_file_list[i]);
              //parse current metadata file as json
              let a = JSON.parse(result);
              var annotationsTemp = $.extend(annotationsTemp,a);
              console.log(annotationsTemp);
              //save modulated metadata in exportFile array
              exportFile[i] = Object.assign({},annotationsTemp);
              exportFile[i]["image_source"] = imageTemp.name;
              exportFile[i]["meta_source"] = meta_name;
              exportFile[i]["checked"] = false;
            }
            found = false;
          }
          console.log("Export");
          console.log(exportFile);

          //set data for download file
          let filename = "poseannotatorFile.json";
          let text = JSON.stringify(exportFile);

          //start download
          download(filename, text);

        }else{
          alert("No Changes made!");
        }
      }

      //function for creating and downloading a zip file with all updated json files
      async function exportFinished(){
        //save changes on current picture
        cacheAnnotations();

        let exportFile = [];
        let found = false;

        //checks if there are unsaved Changes
        if(unsavedChanges[0]){
          for(let i = 0; i < meta_file_list.length; i++){
            //checks if there are unsaved Changes in the current metadata-file
            for(let j in unsavedChanges){
              if(i == j){
                found = true;

                let result = await readFileAsync(meta_file_list[i]);
                //parse current metadata file as json
                let a = JSON.parse(result);
                //overwrite metadata with unsavedChanges
                a["people"] = unsavedChanges[j]["people"];

                exportFile[i] = Object.assign({}, a);
              }
            }
            //current image has no changes yet
            if(found == false){
              //wait for the results of the file reading process
              let result = await readFileAsync(meta_file_list[i]);
              //parse current metadata file as json
              let a = JSON.parse(result);
              //save metadata in exportFile array
              exportFile[i] = Object.assign({},a);
            }
            found = false;
          }
          console.log("Export");
          console.log(exportFile);

          //create zip element
          let zip = new JSZip();

          //add all metadata files to zip element
          for(let i = 0; i < exportFile.length; i++){
            let text = JSON.stringify(exportFile[i]);
            let filename = meta_file_list[i]["name"];
            zip.file(filename, text);
          }

          //generate zip file and download it
          zip.generateAsync({type:"blob"}).then(function(blob){
            console.log(zip);
            saveAs(blob, "pa-export-files.zip");
          }, function (err){
            console.log("Error in zipping");
          });

        }else{
          alert("No Changes made!");
        }
      }

      //helper function to wrap file reading process in a promise that allows managing asynchronicity
      function readFileAsync(file){
        return new Promise((resolve, reject) => {
          let reader = new FileReader ();

          reader.onload = () => {
            resolve(reader.result);
          };

          reader.onerror = reject;

          reader.readAsText(file);
        })
      }

      //function for creating a html element that will trigger the download link and destroying the element afterwards
      function download(filename, text){
        let element = document.createElement("A");
        element.setAttribute("href", "data:text/plain;charset=utf-8," + encodeURIComponent(text));
        element.setAttribute("download", filename);

        element.style.display = "none";
        document.body.appendChild(element);

        element.click();

        document.body.removeChild(element);
      }

      //function for display of file names in tool bar
      function displayFileList(){
        fileview = document.getElementById("fileview");
        for(let i = 0; i < image_file_list.length; i++){
          let li = document.createElement("LI");
          let a = document.createElement("A");
          a.setAttribute("href", "javascript:specificImage(" + String(i) + ");");
          a.setAttribute("id", String(i) + "_link");
          a.innerHTML = "(" + String(i + 1) + ") " + String(image_file_list[i].name);
          li.appendChild(a);
          fileview.appendChild(li);
        }
      }

      //note to future self: maybe the undo all changes function IS possible.
      //Try to delete the cacheAnnotations at the end of the function.
      //If you move to an other image and return back to the one where a pose has been deleted it is possible to restore the annotations

      //function to delete whole selected pose
      function deletePose(){
        if(confirm("Are you shure you want to delete this pose? You cannot undo this step and other changes made on this image!")){
          cacheAnnotations();
          //get pose id of selected pose
          let elId = selectedPoseElements[0].getAttributeNS(null, "id");
          let ids = elId.split(" ");
          //remove pose out of annotations
          let tempClone = Object.assign({}, unsavedChanges);
          tempClone[current_image_id]["people"].splice(parseInt(ids[0]),1)[0];
          unsavedChanges = Object.assign({}, tempClone);

          //remove all svg elements of pose
          for(let i = 0; i < selectedPoseElements.length; i++){
            selectedPoseElements[i].remove();
          }

          //update ids of svg elements that are left accordingly to the new index of annotation array
          let svg = document.getElementById("svg");
          for(let i = 0; i < svg.childNodes.length; i++){
            let tempElId= svg.childNodes[i].getAttributeNS(null, "id");
            let tempIds = tempElId.split(" ");
            let tempPoseId = parseInt(tempIds[0]);

            if(tempPoseId > parseInt(ids[0])){
              let newPoseId = tempPoseId -1;
              let newId = newPoseId.toString() + " " + tempIds[1];

              svg.childNodes[i].setAttributeNS(null, "id", newId);
            }
          }
          //disable deletion button
          document.getElementById("poseDelButton").disabled = true;
        }
      }
    </script>
    <!-- Latest compiled and minified CSS -->
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css">

<!-- jQuery library -->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>

<!-- Popper JS -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.16.0/umd/popper.min.js"></script>

<!-- Latest compiled JavaScript -->
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.0/js/bootstrap.min.js"></script>
  </body>
</html>
