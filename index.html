<!DOCTYPE html>
<html>
  <head>
    <title>Pose Annotator</title>
    <meta charset="UTF-8">
    <meta name="author" content="Cristian Ortega Singer">
    <script src="https://code.jquery.com/jquery-latest.js"></script>
    <style>
      div {border-style: dotted;}
      body {display: grid;}
      #header{
        grid-column: 1/span 3;
        grid-row: 1/ span 2;
      }
      #sidebar{
        grid-column: 1;
        grid-row: 2/span 7;
      }
      #workspace{
        grid-column: 2/span 3;
        grid-row: 2/span 5;
        grid-template-columns: max-content;
      }

      #footer{
        grid-column: 1/span 3;
        grid-row: 7;
      }

      .gridItem{display:grid;}

      #img-svg-wrap{
        position: relative;
        display: inline-block;
      }

      #image{
        display: absolute;
        max-width: 100%;
        min-width: 100%;
        height: auto;
      }

      #svg{
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
      }

      line{
        fill:none;
        stroke-width:3;
      }
      .black{
        stroke:black;
      }
      .orange{
        stroke:orange;
      }

      .point{

      }
    </style>
  </head>
  <body>
    <div id="header" class="gridItem">
      Pose Annotator
      <form name="upload-metadata">
        <input type="file" id="metadata" accept="application/json" multiple>
        </br>
        <input type="file" id="images" accept="image/*" multiple>
        <button type="button" id="imageSubmit" onclick="handleFiles();">Load Files</button>
      </form>
    </div>
    <div id="main" class="gridItem">
      <div id="sidebar" class="gridItem">
        Here are going to be all the tools and an overview of the images
        <div id="tools">Tools</div>
        <div id="files">Files</div>
        <div id="arrows">
          <button type="button" id="lastPic" onclick="previousImage();">Prev</button>
          <button type="button" id="nextPic" onclick="nextImage();">Next</button>
        </div>
      </div>
      <div id="workspace" class="gridItem">
        <div id="img-svg-wrap">
          <img x= 0 y= 0 id="image" href="" alt="current Picture">
          <svg id="svg" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" onload="draggable(evt)">

          </svg>
        </div>
      </div>
    </div>
    <div id="footer" class="gridItem">
      Footer
    </div>

    <script type="text/javascript">
    "use strict";

    //initializing variables
      var IMG_FILEPATH = "img/";
      var META_FILEPATH = "metadata/";
      var single_meta_file = false;
      var meta_file_list = {};
      var annotations;
      var image_file_list = {};
      var current_image_id;
      var current_image_source;
      var unsavedChanges = {};
      var color = "black";

      var bodyparts = {};

      var bodyschema = {
        "head1" : [0, 15],
        "head2" : [0, 16],
        "head3" : [15, 17],
        "head4" : [16, 18],
        "spine1": [0, 1],
        "spine2": [1, 8],
        "armL1" : [1, 2],
        "armL2" : [2, 3],
        "armL3" : [3, 4],
        "armR1" : [1, 5],
        "armR2" : [5, 6],
        "armR3" : [6, 7],
        "legL1" : [8, 9],
        "legL2" : [9, 10],
        "legL3" : [10, 11],
        "legR1" : [8, 12],
        "legR2" : [12, 13],
        "legR3" : [13, 14],
        "footL1": [11, 22],
        "footL2": [22, 23],
        "footL3": [11, 24],
        "footR1": [14, 19],
        "footR2": [19, 20],
        "footR3": [14, 21]
      };

      var selectedElement;
      var offset;
      var transform;
      var bbox;
      var minX;
      var minY;
      var maxX;
      var maxY;
      var boundaryX1 = 0;
      var boundaryY1 = 0;
      var boundaryX2 = document.getElementById("svg").width;
      var boundaryY2 = document.getElementById("svg").height;

      var svgNS = "http://www.w3.org/2000/svg";

      // Check for the various File API support.
      if (!window.File || !window.FileReader || !window.FileList || !window.Blob) {
        alert('The File APIs are not fully supported in this browser.');
      }

      //various event listeners for tracking key and mouse navigation
      document.addEventListener('keydown', function(event) {
        if(event.keyCode == 37) {
          console.log('Left was pressed');
          previousImage();
        }
        else if(event.keyCode == 39) {
          console.log('Right was pressed');
          nextImage();
        }
        else if(event.keyCode == 40) {
          console.log('Down was pressed');
          changeAnnoColor();
        }
      });

      //function for making the annotation points draggable
      function draggable(evt){
        var svg = evt.target;

        //set event listeners for mouse movement
        svg.addEventListener("mousedown", startDrag);
        svg.addEventListener("mousemove", drag);
        svg.addEventListener("mouseup", endDrag);
        svg.addEventListener("mouseleave", endDrag);

        //track mouseposition on screen if mouse interacts with svg
        function getMousePos(evt){
          var ctm = svg.getScreenCTM();
          if(evt.touches){
            evt = evt.touches[0];
          }
          return{
            x: (evt.clientX - ctm.e) / ctm.a,
            y: (evt.clientY - ctm.f) / ctm.d
          };
        }

        // handles mousedown event, starts dragging process
        function startDrag(evt){
          var svgtemp = document.getElementById("svg");

          //set boundaries to Imagesize so that it is impossible to drag points out of view
          boundaryX2 = svgtemp.width.baseVal.value;
          boundaryY2 = svgtemp.height.baseVal.value;

          //console.log("Boundaries:");
          //console.log(boundaryX2);
          //console.log(boundaryY2);

          //correct mouse offset in relation to svg through a transformation
          if(evt.target.classList.contains("point")){
            selectedElement = evt.target;
            offset = getMousePos(evt);
            //console.log(offset);

            var transforms = selectedElement.transform.baseVal;

            if(transforms.length === 0 || transforms.getItem(0).type !== SVGTransform.SVG_TRANSFORM_TRANSLATE){
              var translate = svg.createSVGTransform();
              translate.setTranslate(0,0);
              selectedElement.transform.baseVal.insertItemBefore(translate,0);
            }

            transform = transforms.getItem(0);
            offset.x -= transform.matrix.e;
            offset.y -= transform.matrix.f;

            //console.log(offset.x);
            //console.log(offset.y);

            //set boundaries according to the collision box of svg element
            bbox = selectedElement.getBBox();
            minX = boundaryX1 - bbox.x;
            maxX = boundaryX2 -bbox.x - bbox.width;
            minY = boundaryY1 - bbox.y;
            maxY = boundaryY2 - bbox.y - bbox.height;
          }
        }

        //handles mousemove event; the dragging process itself
        function drag(evt){
          if(selectedElement){
            evt.preventDefault();
            var coord = getMousePos(evt);
            var dx = coord.x - offset.x;
            var dy = coord.y - offset.y;

            //make shure svg element stays within boundaries
            if(dx < minX){
              dx = minX;
            }else if(dx >maxX){
              dx = maxX;
            }

            if(dy < minY){
              dy = minY;
            }else if(dy > maxY){
              dy = maxY;
            }
            //set new position for svg point
            transform.setTranslate(dx, dy);

            //set new position for svg lines if selected point is one of the coordinates
            //get point id and bodyschema ids for identifing correct lines
            var pointId = selectedElement.getAttribute("id");
            var ids = pointId.split(" ");
            var pointschemaId = ids[1];
            var poseId = ids[0];
            //console.log("Pointschema Id: " + pointschemaId);
            var lineIds = {};
            //get all bodyparts that have the right identifier
            for(var i in bodyschema){
              for(var j = 0; j < bodyschema[i].length; j++){
                if(bodyschema[i][j] == pointschemaId){
                  lineIds[poseId + " " + i] = j;
                }
              }
            }

            for(var k in lineIds){
              //console.log(k);
              var line = document.getElementById(k.toString());

              if(line){
                if(lineIds[k] == 0){
                  line.setAttributeNS(null,"x1", coord.x);
                  line.setAttributeNS(null,"y1", coord.y);
                  //console.log("changed x1 and y1");
                }else if(lineIds[k] == 1){
                  line.setAttributeNS(null,"x2", coord.x);
                  line.setAttributeNS(null,"y2", coord.y);
                  //console.log("changed x2 and y2");
                }else{
                  console.log("An error occured. Look in source code function pointchange() to see what happened.");
                }
              }
            }
          }
        }

        //handles mouseup and mouseleave events; stops dragging process
        function endDrag (evt){
          selectedElement = false;
        }
      }



        //Not finished will be included in future versions: load json file if the annotations are saved in only one json file
      function loadMetaFileSingle(){
        /**single_meta_file = true;

        //console.log(meta_file_list);

        //for every selected file launch a file reader to get content of file as a string array
        for(var i = 0; i < meta_file_list.length; i++){
          var d = meta_file_list[i];
          //console.log(d);
          //create file reader
          var reader = new FileReader();
          //assign file reader with function
          reader.onload = getAnnotations;
          //execute file reader, after that start loading annotations
          reader.readAsText(d).then(loadAnnotationsSingle());
        }
        function getAnnotations(t, callback = function(){loadAnnotations();}){
          let lines = t.target.result;
          //parse result string as JSON
          var a = JSON.parse(lines);
          //add annotations of file to annotation array
          annotations = $.extend(annotations,a);
          //console.log("Annotations:");
          //console.log(annotations);
          callback();
        }**/

      }

      //load current json file if the annotations are saved in multiple json files
      function loadMetaFiles(){
        single_meta_file = false;

        //console.log(meta_file_list);

        //get name of json file through the name of the image file
        var id = current_image_source.split(".")[0];
        //create a new regex pattern
        var patt = new RegExp(id + "_");
        var meta_id;
        //console.log(id);
        //search in loaded meta files for the correct file via file name and save file in meta_id
        for(var i = 0; i < meta_file_list.length; i++){
          var d = meta_file_list[i];
          if(patt.test(d.name)){
            //console.log(d);
            meta_id = d;
          }
        }

        //if file found launch a file reader to get content of file as a string array
        if(meta_id){
          var reader = new FileReader();
          reader.onload = getAnnotations;
          //console.log(meta_id);
          reader.readAsText(meta_id);
        }

        function getAnnotations(t, callback = function(){loadAnnotations();}){
          //console.log(callback);
          let lines = t.target.result;
          var a = JSON.parse(lines);
          annotations = $.extend(annotations,a);
          //console.log("Annotations:");
          //console.log(annotations);
          callback();
        }
      }

      //initiate the file reading process of json and image files
      function handleFiles(){
        //get json and image files from the file selector
        image_file_list = document.getElementById("images").files;
        meta_file_list = document.getElementById("metadata").files;

        //catching errors
        if(!image_file_list[0]){
          alert("You have to select image files before you can continue!");
        }else if(!meta_file_list[0]){
          alert("You have to select JSON files before you can continue!");
        }else if(image_file_list[0] && meta_file_list[0]){
          if(annotations){
            if(confirm("Annotations already included! Do you want to replace annotation File(s)?")){
              current_image_id = 0;
              loadImage();
              annotations = {};
              if(meta_file_list.length > 1){
                loadMetaFiles();
              }else{
                loadMetaFileSingle();
              }
            }
          }else{
            current_image_id = 0;
            loadImage();
            annotations = {};
            //check if there are multiple json files or just one
            if(meta_file_list.length > 1){
              loadMetaFiles();
            }else{
              loadMetaFileSingle();
            }
          }
        }
      }

      //display image
      function loadImage(){
        destroySvgEl();
        if(!image_file_list[current_image_id]){
          //console.log(current_image_id);
          alert("An Error occured! No Image Id found.")
        }else{
          var imag = document.getElementById("image");
          current_image_source = image_file_list[current_image_id].name;

          if(imag.complete){
            var new_image = new Image();
            new_image.id = "image";
            new_image.src = IMG_FILEPATH + current_image_source;
            imag.parentNode.insertBefore(new_image, imag);
            imag.parentNode.removeChild(imag);
          }
        }
      }

      //function for loading next image with annotations
      function nextImage(){
        cacheAnnotations();
        if(current_image_id >= image_file_list.length -1){
          current_image_id = 0;
        }else{
          current_image_id++;
        }
        loadImage();
        if(single_meta_file){
          loadMetaFileSingle();
        }else{
          loadMetaFiles();
        }
      }

      //function for loading previous image with annotations
      function previousImage(){
        cacheAnnotations();
        if(current_image_id <= 0){
          current_image_id = image_file_list.length - 1;
        }else{
          current_image_id--;
        }
        loadImage();
        if(single_meta_file){
          loadMetaFileSingle();
        }else{
          loadMetaFiles();
        }
      }

      //Not finished will be included in future versions: load annotations if there is only one json file
      function loadAnnotationsSingle(){
        /**var results = [];
        var anno_image_id;

        //search for the current image id in annotations
        for(var j=0; j < annotations["images"].length; j++){
          if(annotations["images"][j]["file_name"] == current_image_source){
            anno_image_id = annotations["images"][j]["id"];
          }
        }
        //console.log(anno_image_id);

        //if found save annotations for specific picture in results
        if(anno_image_id){
          for(var k= 0; k < annotations["annotations"].length; k++){
            if(annotations["annotations"][k]["image_id"] == anno_image_id){
              results.push(annotations["annotations"][k]);
            }
          }
        }else{
          //console.log("image_id not found");
        }
        //console.log(results);
        if(results.length > 0){
          displayAnnotations(results);
        }**/
      }

      // load annotations if there are multiple json files
      function loadAnnotations(){
        var results = [];
        if(current_image_id in unsavedChanges){
          var p = unsavedChanges[current_image_id]["people"];
        }else{
          var p = annotations["people"];
        }
        //console.log(p);
        //save pose keypoints in results
        for(var i = 0; i < p.length; i++){
          var t = p[i]["pose_keypoints_2d"];
          //console.log(t);
          results.push(t);
        }
        //console.log("Results:");
        //console.log(results);
        //start disply for each pose
        for(var j= 0; j < results.length; j++){
          displayAnnotations(results[j], j);
        }
      }

      //prepare pose keypoints for display as svg
      function displayAnnotations(r, counter){
        var counter = counter;
        var points = [];

      //delete z variable (keypoint schema x,y,z with z = confidence level)
        for(var i = 0; i < r.length; i++){
          if((i+1) % 3 != 0){
            points.push(r[i]);
          }
        }

        //console.log("Points:");
        //console.log(points);

        var newpoints = {};
        for(var i = 0; i < points.length; i += 2){
            var id = i/2;
            newpoints[id] = [points[i], points[i+1]];
        }
        //console.log(newpoints);

        //set point schema for display
        bodyparts = {
          head1 : [newpoints[0], newpoints[15]],
          head2 : [newpoints[0], newpoints[16]],
          head3 : [newpoints[15], newpoints[17]],
          head4 : [newpoints[16], newpoints[18]],
          spine1: [newpoints[0], newpoints[1]],
          spine2: [newpoints[1], newpoints[8]],
          armL1 : [newpoints[1], newpoints[2]],
          armL2 : [newpoints[2], newpoints[3]],
          armL3 : [newpoints[3], newpoints[4]],
          armR1 : [newpoints[1], newpoints[5]],
          armR2 : [newpoints[5], newpoints[6]],
          armR3 : [newpoints[6], newpoints[7]],
          legL1 : [newpoints[8], newpoints[9]],
          legL2 : [newpoints[9], newpoints[10]],
          legL3 : [newpoints[10], newpoints[11]],
          legR1 : [newpoints[8], newpoints[12]],
          legR2 : [newpoints[12], newpoints[13]],
          legR3 : [newpoints[13], newpoints[14]],
          footL1: [newpoints[11], newpoints[22]],
          footL2: [newpoints[22], newpoints[23]],
          footL3: [newpoints[11], newpoints[24]],
          footR1: [newpoints[14], newpoints[19]],
          footR2: [newpoints[19], newpoints[20]],
          footR3: [newpoints[14], newpoints[21]]
        }
        //delete all points that have 0 value (if 0 bodypart is not assigned)
        for(var i in bodyparts){
          //console.log("id: " + i);
          if((bodyparts[i][0][0] == 0) || (bodyparts[i][1][1] == 0)){
            delete bodyparts[i];
          }
        }
        //console.log(bodyparts);

        //stringify point arrays and start line creation
        for(var id in bodyparts){
          if((bodyparts[id][0])&& (bodyparts[id][1])){
            var x1 = bodyparts[id][0][0].toString();
            var y1 = bodyparts[id][0][1].toString();
            var x2 = bodyparts[id][1][0].toString();
            var y2 = bodyparts[id][1][1].toString();
          }
          var idtemp = counter.toString() + " " + id.toString();
          createLine(x1, y1, x2, y2, idtemp);
        }

        for(var id in newpoints){
          var x = newpoints[id][0];
          var y = newpoints[id][1];
          var strx = x.toString();
          var stry = y.toString();
          //console.log(strx + " " + stry);
          var idtemp = counter.toString() + " " + id.toString();
          createPoint(strx, stry, idtemp);
        }
      }

      function createPoint(x, y, id){
        var point = document.createElementNS(svgNS, "circle");
        var classes = color + " point";
        point.setAttributeNS(null,"cx", x);
        point.setAttributeNS(null, "cy", y);
        point.setAttributeNS(null, "r", "5");
        point.setAttributeNS(null, "class", classes);
        point.setAttributeNS(null,"id", id.toString());

        document.getElementById("svg").appendChild(point);
      }

      function createLine(x1, y1, x2, y2, id){
        var line = document.createElementNS(svgNS, "line");
        line.setAttributeNS(null, "x1", x1);
        line.setAttributeNS(null, "y1", y1);
        line.setAttributeNS(null, "x2", x2);
        line.setAttributeNS(null, "y2", y2);
        line.setAttributeNS(null, "class", color);
        line.setAttributeNS(null, "id", id);
        line.setAttributeNS(null, "onload", "pointchange(evt)");

        document.getElementById("svg").appendChild(line);
      }

      //destroy all displayed svg elements
      function destroySvgEl(){
        var svg = document.getElementById("svg");
        while (svg.firstChild) {
          svg.removeChild(svg.lastChild);
        }
      }

      //Not finished will be included in future versions: prepare pose keypoints for display as svg if only one json file is given
      function displayAnnotationsSingle(r){
        /**var points = [];
        for(var i = 0; i < r.length; i++){
          var rawPoints = r[i].keypoints;
          //console.log(rawPoints);
          for(var j = 0; j < rawPoints.length; j++){
            if((j+1) % 3 != 0){
              points.push(rawPoints[j]);
            }
          }
          //console.log(points);

          //stringify point arrays and start polyline creation
          var strPoints = points.toString();
          var imag = document.getElementById("image");
          if(imag.complete){
            var poly = new SVGPolylineElement();
            poly.id = "annotation" + i;
            poly.points = strPoints;
            poly.parentNode.insertBefore(poly, imag);
          }
        }**/
      }

      //change css class of svg elements to change appearance for the current and following annotations
      function changeAnnoColor(){
        var svg = document.getElementById("svg");
        if(color == "black"){
          color = "orange"
        }else{
          color ="black"
        }
        for(var i = 0; i < svg.childNodes.length; i++){
          svg.childNodes[i].setAttributeNS(null, "class", color);
        }
      }

      //function for chaching the made changes
      function cacheAnnotations(){
        var svg = document.getElementById("svg");
        var children = svg.childNodes;
        var pointcounter = 0;


        for(var i = 0; i < children.length; i++){
          if(children[i].classList.contains("point")){

            var cx = children[i].getAttribute("cx");
            var cy = children[i].getAttribute("cy");

            // flatten the transformations made to the svg points to get new coordinates
            if(children[i].transform.baseVal.length != 0){
              var matrix = children[i].transform.baseVal.consolidate().matrix;
              var cache = svg.createSVGPoint();
              cache.x = cx;
              cache.y = cy;
              cache = cache.matrixTransform(matrix);
              var x = cache.x;
              var y = cache.y;
            }else{
              var x = cx;
              var y = cy;
            }

            //get Ids to save coordinates in the given schema and at the right index
            var pointId = children[i].getAttribute("id");
            var ids = pointId.split(" ");
            var pointschemaId = ids[1];
            var poseId = ids[0];
            //console.log("Ids: " + "point: " + pointschemaId + " pose: "+ poseId);

            var intPose = parseInt(poseId);
            var intId = parseInt(pointschemaId);
            var id1 = (intId * 2) + pointcounter;
            var id2 = id1 + 1;

            if(intId == 24){
              pointcounter = 0;
            }else{
              pointcounter++;
            }
            //console.log(intId, id1, id2);

            //overwrite old coordinates with new ones
            //console.log("Before: " + annotations["people"][poseId]["pose_keypoints_2d"][id1] + " " + annotations["people"][poseId]["pose_keypoints_2d"][id2]);
            annotations["people"][poseId]["pose_keypoints_2d"][id1] = x;
            annotations["people"][poseId]["pose_keypoints_2d"][id2] = y;

            //console.log("After: " + annotations["people"][poseId]["pose_keypoints_2d"][id1] + " " + annotations["people"][poseId]["pose_keypoints_2d"][id2]);

          }
        }

        //clone annotation object and save annotations with image id in unsavedChanges {}
        unsavedChanges[current_image_id] =  Object.assign({},annotations);
        console.log(unsavedChanges);
      }

    </script>
  </body>
</html>
